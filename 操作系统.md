# REFERENCE

- [linux C++后台开发面试题](<https://zhuanlan.zhihu.com/p/103027724>)
- [知乎：程序员面试，面试官更注重代码量、项目经验还是操作系统、数据结构这种基础课程？两者比例是五五开还是多少？](https://www.zhihu.com/question/264198516)
- [复习参考指北](<https://blog.csdn.net/qq_40840459/category_7280605.html>)
- 

# 操作系统

## 进程和线程

1. 分别的概念 区别 适用范围 它们分别的通讯方式 不同通讯方式的区别优缺点
> [知乎 线程和进程的区别是什么？](<https://www.zhihu.com/question/25532384>)
> 做个简单的比喻：进程=火车，线程=车厢
>
> - 线程在进程下行进（单纯的车厢无法运行）
> - 一个进程可以包含多个线程（一辆火车可以有多个车厢）
> - 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
> - 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
> - 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
> - 进程间不会相互影响，**一个线程挂掉将导致整个进程挂掉**（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
> - 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
> - 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
> - 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

> 线程作为进程的一部分，扮演的角色就是怎么利用中央处理器去运行代码。这其中牵扯到的最重要资源的是中央处理器和其中的寄存器，和线程的栈（stack）。这里想强调的是，线程关注的是中央处理器的运行，而不是内存等资源的管理。

> [操作系统—进程概念](<https://blog.csdn.net/qq_40840459/article/details/80058705>)
>
> **进程与程序**
>
> - 程序：代码段+数据段
> - 进程：代码段+数据段+堆栈+[PCB](#pcb)
>
> 进程是操作系统分配资源的基本单位，也是最小单位。每个进程有自己的独立地址空间和执行状态。 操作系统内核一定要有一个PCB来管理进程。（OS角度）
>
> **进程的状态**
>
> - 运行态：该进程正在运行，即进程正在占用CPU。
> - 就绪态：进程已经具备执行的一切条件，正在等待分配CPU的处理时间片。
> - 等待态：进程正在等待某个事件或某个资源。等待态又分为可中断等待和不可中断等待两种。可中断的等待进程可被信号中断，而不可中断的等待进程不能被信号中断。
> - 停止状态：当进程收到一个`SIGSTOP`信号后，便由运行态进入停止状态，当收到`SIGCONT`信号时又会恢复运行态，该状态主要用于调试。
> - 僵死状态（终止状态）：进程已终止，但其`task_struct `结构仍在内存中。顾名思义，处于这种状态的进程实际是死进程。
>
> ![](https://img-blog.csdn.net/20180423173237921?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODQwNDU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



### [进程间通信（IPC）介绍](https://www.cnblogs.com/CheeseZH/p/5264465.html)

这个文章总结的很全面还有例子。

#### 管道

> 当一个管道建立时，它会创建两个文件描述符：`fd[0]`为读而打开，`fd[1]`为写而打开

这个`main`里的参数有点像，又有点想进程的标准输入输出的参数。有例子：

> ```c++
> #include<stdio.h>
> #include<unistd.h>
> 
> int main()
> {
> int fd[2];  // 两个文件描述符
> pid_t pid;
> char buff[20];
> 	printf("[line:%d] Parent pid:%d\n",__LINE__,getpid());
> 
> if(pipe(fd) < 0)  // 创建管道
>   printf("Create Pipe Error!\n");
> 
> if((pid = fork()) < 0)  // 创建子进程
>   printf("Fork Error!\n");
> else if(pid > 0)  // 父进程
> {
> 	printf("Parent pid:%d\n",pid);
>   close(fd[0]); // 关闭读端
>   write(fd[1], "hello world\n", 12);//12就是字符数吧
> }
> else
> {
> 	printf("Children pid:%d\n",pid);
>   close(fd[1]); // 关闭写端
>   read(fd[0], buff, 20);
>   printf("%s", buff);
> }
> 
> return 0;
> }
> ```
> OutPut:
> ```shell
> [line:9] Parent pid:14167 # 这是真正的Parent Thread
> Parent pid:14168 # 这是fork出来那个执行的
> Children pid:0  # 这是fork()的返回值，可参考frok用法
> hello world
> ```
> 还真能实现进程通信，但确实如前所述只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）
>

> [linux编程之pipe()函数](https://www.cnblogs.com/kunhu/p/3608109.html)
> ![pipe](https://images2015.cnblogs.com/blog/323808/201603/323808-20160311094030069-935122142.png)
>
> ```c++
> #include<unistd.h>
> int pipe(int filedes[2]); //返回值：成功，返回0，否则返回-1。参数数组包含pipe使用的两个文件的描述符。fd[0]:读管道，fd[1]:写管道。必须在fork()中调用pipe()，否则子进程不会继承文件描述符。两个进程不共享祖先进程，就不能使用pipe。
> ```
>
> 管道最大的劣势就是没有名字，只能用于有一个共同祖先进程的各个进程之间。FIFO代表先进先出，但它是一个单向数据流，也就是半双工，和管道不同的是：每个FIFO都有一个路径与之关联，从而允许无亲缘关系的进程访问。  

#### FIFO 命名管道

> 原型：
>
> ```c++
> #include <sys/stat.h>
> int mkfifo(const char *pathname, mode_t mode);
> // 返回值：成功返回0，出错返回-1。
> // 其中的 mode 参数与open函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。
> ```
>
> FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时**清除数据**，并且“先进先出”。下面的例子演示了使用 FIFO 进行 IPC 的过程：
>
> ```c
> /*write_fifo.c*/
> #include<stdio.h>
> #include<stdlib.h>   // exit
> #include<fcntl.h>    // O_WRONLY
> #include<sys/stat.h>
> #include<time.h>     // time
> 
> int main()
> {
>     int fd;
>     int n, i;
>     char buf[1024];
>     time_t tp;
> 
>     printf("I am %d process.\n", getpid()); // 说明进程ID
> 
>     if((fd = open("../fifo1", O_WRONLY)) < 0) // 以写打开一个FIFO
>     {
>         perror("Open FIFO Failed");
>         exit(1);
>     }
> 
>     for(i=0; i<10; ++i)
>     {
>         time(&tp);  // 取系统当前时间
>         n = sprintf(buf,"Process %d's time is %s",getpid(),ctime(&tp));
>         printf("n: %d, Send message: %s", n, buf); // 打印
>         if(write(fd, buf, n+1) < 0)  // 写入到FIFO中
>         {
>             perror("Write FIFO Failed");
>             close(fd);
>             exit(1);
>         }
>         sleep(1);  // 休眠1秒
>     }
> 
>     close(fd);  // 关闭FIFO文件
>     return 0;
> }
> ```
>
> ```c
> /*read_fifo.c*/
> #include<stdio.h>
> #include<stdlib.h>
> #include<errno.h>
> #include<fcntl.h>
> #include<sys/stat.h>
> 
> int main()
> {
>     int fd;
>     int len;
>     char buf[1024];
> 	
> 	printf("I am %d process.\n", getpid()); // 说明进程ID
> 
>     if(mkfifo("../fifo1", 0666) < 0 && errno!=EEXIST) // 创建FIFO管道
>         perror("Create FIFO Failed\n");
> 
>     if((fd = open("../fifo1", O_RDONLY)) < 0)  // 以读打开FIFO
>     {
>         perror("Open FIFO Failed");
>         exit(1);
>     }
> 
>     while((len = read(fd, buf, 1024)) > 0) // 读取FIFO管道
>         printf("Read message: %s", buf);
> 
>     close(fd);  // 关闭FIFO文件
>     return 0;
> }
> ```
>
> Wonderful，My first multiprocessor program

`mkfifo`

> [mkfifo函数使用](<https://blog.csdn.net/superywf/article/details/73438465>)
>
> `mkfifo()`会依参数`pathname`建立特殊的`FIFO`文件，**该文件必须不存在，创建后文件存在**，
>
> ```shell
> prw-r--r--  1 root  root       0 6月   9 17:09 fifo1|
> ```
>
> 而参数`mode`为该文件的权限（mode%~umask），因此 umask值也会影响到`FIFO`文件的权限。

 `error 1: Create FIFO Failed: Operation not permitted`

   >[在共享文件夹里面创建管道mkfifo失败ubuntu](https://www.cnblogs.com/kirk1995/p/6654578.html) 
   >
   >原来是文件系统的问题，window的文件系统不支持管道文件，只要把创建的管道文件路径设为linux的本地文件夹就行了。刚开始我以为是hgfs文件夹权限的问题，于是在网上搜啊，还是没找到更改ubuntu下hgfs文件夹权限的方法，查到的都是说共享文件夹特殊，还是不要动的话。
   >
   >其实是和权限没关系的，就是文件系统问题，所以就算改了也还是不行的。

`errno`

   >[Linux errno详解](https://www.cnblogs.com/Jimmy1988/p/7485133.html) 
   >Linux中系统调用的错误都存储于 `errno`中，`errno`由操作系统维护，存储就近发生的错误，即下一次的错误码会覆盖掉上一次的错误。
   >
   >查看系统中所有的`errno`所代表的含义，可以采用如下的代码：
   >
   >```c++
   >/* Function: obtain the errno string
   >*   char *strerror(int errno)
   >*/
   >
   >#include <stdio.h>
   >#include <string.h>     //for strerror()
   >//#include <errno.h>
   >int main()
   >{
   >    int tmp = 0;
   >    for(tmp = 0; tmp <=256; tmp++)
   >    {
   >        printf("errno: %2d\t%s\n",tmp,strerror(tmp));
   >    }
   >    return 0;
   >}
   >// Linux中，在头文件 /usr/include/asm-generic/errno-base.h 对基础常用errno进行了宏定义：
   >// #define EEXIST      17  /* File exists */
   >```

`perror`

> [C 库函数 - perror()](<https://www.runoob.com/cprogramming/c-function-perror.html>)
>
> C 库函数 **void perror(const char \*str)** 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 **str**，后跟一个冒号，然后是一个空格。
>
> ```c++
> void perror(const char *str)
> ```
>
> 

`fork`的用法：

> [Linux中fork（）函数详解](https://www.cnblogs.com/bastard/archive/2012/08/31/2664896.html)
>
> **fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：**
> 1）在父进程中，fork返回新创建子进程的进程ID；
> 2）在子进程中，fork返回0；
> 3）如果出现错误，fork返回一个负值；
>
> 引用一位网友的话来解释`fpid`的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的`fpid`(p 意味point)指向子进程的进程id,因为子进程没有子进程，所以其`fpid`为0.
>
> 创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。
> 每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过`getpid()`函数获得，还有一个记录父进程pid的变量，可以通过`getppid()`函数获得变量的值。
>
> [*9 June 2020*]这个写的不错，还有`fork`的进阶和高阶，我还没看。
>
> `nowcode`:最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。

`vfork`

> - `vfork`创建的子进程与父进程共享地址空间。
> - `fork`父子进程交替运行，`vfork`子进程运行，父进程阻塞，直到子进程结束
> - 每个系统上的`vfork`都有问题，建议不要使用

#### 消息队列

> ```c
> #include <sys/msg.h>
> // 创建或打开消息队列：成功返回队列ID，失败返回-1
> int msgget(key_t key, int flag);
> // 添加消息：成功返回0，失败返回-1
> int msgsnd(int msqid, const void *ptr, size_t size, int flag);
> // 读取消息：成功返回消息数据的长度，失败返回-1
> int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
> // 控制消息队列：成功返回0，失败返回-1
> int msgctl(int msqid, int cmd, struct msqid_ds *buf);
> ```
>
> ```shell
> sudo gcc msg_client.c -o msg_c; sudo gcc msg_server.c  -o msg_s
> ```
>
> ```c
> /*msg_server.c*/
> #include <stdio.h>
> #include <stdlib.h>
> #include <sys/msg.h>
> 
> // 用于创建一个唯一的key
> #define MSG_FILE "/etc/passwd"
> 
> // 消息结构
> struct msg_form {
>  long mtype;
>  char mtext[256];
> };
> 
> int main()
> {
>  int msqid;
>  key_t key;
>  struct msg_form msg;
> 
>  // 获取key值
>  if((key = ftok(MSG_FILE,'z')) < 0)
>  {
>      perror("ftok error");
>      exit(1);
>  }
> 
>  // 打印key值
>  printf("Message Queue - Server key is: %d.\n", key);
> 
>  // 创建消息队列
>  if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
>  {
>      perror("msgget error");
>      exit(1);
>  }
> 
>  // 打印消息队列ID及进程ID
>  printf("My msqid is: %d.\n", msqid);
>  printf("My pid is: %d.\n", getpid());
> 
>  // 循环读取消息
>  for(;;)
>  {
>      msgrcv(msqid, &msg, 256, 888, 0);// 返回类型为888的第一个消息
>      printf("Server: receive msg.mtext is: %s.\n", msg.mtext);
>      printf("Server: receive msg.mtype is: %d.\n", msg.mtype);
> 
>      msg.mtype = 999; // 客户端接收的消息类型
>      sprintf(msg.mtext, "hello, I'm server %d", getpid());
>      msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
>  }
>  return 0;
> }
> ```
> 在两个终端运行
> ```c
> /*msg_client.c*/
> #include <stdio.h>
> #include <stdlib.h>
> #include <sys/msg.h>
> 
> // 用于创建一个唯一的key
> #define MSG_FILE "/etc/passwd"
> 
> // 消息结构
> struct msg_form {
>  long mtype;
>  char mtext[256];
> };
> 
> int main()
> {
>  int msqid;
>  key_t key;
>  struct msg_form msg;
> 
>  // 获取key值
>  if ((key = ftok(MSG_FILE, 'z')) < 0)
>  {
>      perror("ftok error");
>      exit(1);
>  }
> 
>  // 打印key值
>  printf("Message Queue - Client key is: %d.\n", key);
> 
>  // 打开消息队列
>  if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
>  {
>      perror("msgget error");
>      exit(1);
>  }
> 
>  // 打印消息队列ID及进程ID
>  printf("My msqid is: %d.\n", msqid);
>  printf("My pid is: %d.\n", getpid());
> 
>  // 添加消息，类型为888
>  msg.mtype = 888;
>  sprintf(msg.mtext, "hello, I'm client %d", getpid());
>  msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
> 
>  // 读取类型为999的消息
>  msgrcv(msqid, &msg, 256, 999, 0);
>  printf("Client: receive msg.mtext is: %s.\n", msg.mtext);
>  printf("Client: receive msg.mtype is: %d.\n", msg.mtype);
>  return 0;
> }
> ```
>
> ```
> Message Queue - Client key is: 2047025538.
> My msqid is: 0.
> My pid is: 27106.
> Client: receive msg.mtext is: hello, I'm server 27053.
> Client: receive msg.mtype is: 999.
> ```
>
> ```
> Message Queue - Server key is: 2047025538.
> My msqid is: 0.
> My pid is: 27625.
> Server: receive msg.mtext is: hello, I'm client 27632.
> Server: receive msg.mtype is: 888.
> ```
>
> 

#### 信号量

> **信号量（semaphore）**与已经介绍过的 `IPC` 结构不同，它是一个**计数器**。信号量用于实现进程间的互斥与同步，**而不是用于存储进程间通信数据**。
>
> 1. 信号量用于进程间同步，若要在进程间传递数据需要结合**共享内存**。
> 2. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
> 3. ...
>
> ```c
> #include <sys/sem.h>
> // 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1
> int semget(key_t key, int num_sems, int sem_flags);
> // 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1
> int semop(int semid, struct sembuf semoparray[], size_t numops);
> // 控制信号量的相关信息
> int semctl(int semid, int sem_num, int cmd, ...);
> // 在semop函数中，sembuf结构
> struct sembuf
> {
>     short sem_num; // 信号量组中对应的序号，0～sem_nums-1
>     short sem_op;  // 信号量值在一次操作中的改变量
>     short sem_flg; // IPC_NOWAIT, SEM_UNDO
> }
> ```
>
> 在`semctl`函数中的命令有多种，这里就说两个常用的：
>
> - `SETVAL`：用于初始化信号量为一个已知的值。所需要的值作为联合semun的val成员来传递。在信号量第一次使用之前需要设置信号量。
> - `IPC_RMID`：删除一个信号量集合。**如果不删除信号量，它将继续在系统中存在**，即使程序已经退出，它可能在你下次运行此程序时引发问题，**而且信号量是一种有限的资源**。
>
> ```c
> #include<stdio.h>
> #include<stdlib.h>
> #include<sys/sem.h>
> 
> // 联合体，用于semctl初始化
> union semun
> {
>     int              val; /*for SETVAL*/
>     struct semid_ds *buf;
>     unsigned short  *array;
> };
> 
> // 初始化信号量
> int init_sem(int sem_id, int value)
> {
>     union semun tmp;
>     tmp.val = value;
>     if(semctl(sem_id, 0, SETVAL, tmp) == -1)
>     {
>         perror("Init Semaphore Error");
>         return -1;
>     }
>     return 0;
> }
> 
> // P操作:
> //    若信号量值为1，获取资源并将信号量值-1
> //    若信号量值为0，进程挂起等待
> int sem_p(int sem_id)
> {
>     struct sembuf sbuf;
>     sbuf.sem_num = 0; /*序号*/
>     sbuf.sem_op = -1; /*P操作*/
>     sbuf.sem_flg = SEM_UNDO;/*这个UNDO应该是值啥也不做等待信号量释放的意思吧*/
> 
>     if(semop(sem_id, &sbuf, 1) == -1)
>     {
>         perror("P operation Error");
>         return -1;
>     }
>     return 0;
> }
> 
> // V操作：
> //    释放资源并将信号量值+1
> //    如果有进程正在挂起等待，则唤醒它们
> int sem_v(int sem_id)
> {
>     struct sembuf sbuf;
>     sbuf.sem_num = 0; /*序号*/
>     sbuf.sem_op = 1;  /*V操作*/
>     sbuf.sem_flg = SEM_UNDO;
> 
>     if(semop(sem_id, &sbuf, 1) == -1)
>     {
>         perror("V operation Error");
>         return -1;
>     }
>     return 0;
> }
> 
> // 删除信号量集
> int del_sem(int sem_id)
> {
>     union semun tmp;
>     if(semctl(sem_id, 0, IPC_RMID, tmp) == -1)
>     {
>         perror("Delete Semaphore Error");
>         return -1;
>     }
>     return 0;
> }
> 
> 
> int main()
> {
>     int sem_id;  // 信号量集ID
>     key_t key;
>     pid_t pid;
> 
>     // 获取key值
>     if((key = ftok(".", 'z')) < 0)
>     {
>         perror("ftok error");
>         exit(1);
>     }
> 
>     // 创建信号量集，其中只有一个信号量
>     if((sem_id = semget(key, 1, IPC_CREAT|0666)) == -1)
>     {
>         perror("semget error");
>         exit(1);
>     }
> 	
> 	printf("Create Semaphore number:%d\n",sem_id);
>     // 初始化：初值设为0资源被占用，因此是子进程先执行，因为原本是0，子进程释放后才是1，sem_p操作才有效
>     init_sem(sem_id, 0);
> 
>     if((pid = fork()) == -1)//PS.从这个例子也很容易看出来，fork之后，子进程是接着父进程的点继续执行的
>         perror("Fork Error");
>     else if(pid == 0) /*子进程*/
>     {
>         sleep(2);
>         printf("Process child: pid=%d\n", getpid());
>         sem_v(sem_id);  /*释放资源*/
>     }
>     else  /*父进程*/
>     {
>         sem_p(sem_id);   /*等待资源*/
>         printf("Process father: pid=%d\n", getpid());
>         sem_v(sem_id);   /*释放资源*/
>         del_sem(sem_id); /*删除信号量集*/
>     }
>     return 0;
> }
> ```
>
> Output:
>
> ```shell
> Create Semaphore number:458766
> Process child: pid=3764
> Process father: pid=3763 # 父进程等待信号量，因此在子进程之后运行
> ```
>
> 

[*10 June 2020*] 

对于上述程序，还是有些细节没有深究，包括*信号量是一个有限资源，有多少？*等。

`PV操作`

> [操作系统——PV操作](<https://blog.csdn.net/ws_Ando/article/details/83501519>)
>
> PV操作概念：操作系统中的一种同步机制，实现对于并发进程中临界区的管理。
>
> 并发进程分为两种：
>
> ①无交互的并发进程：每个进程是相互独立的，谁也不影响谁，基本不会用到PV操作。
>
> ②有交互的并发进程：多个进程共享资源，一个进程的运行，有可能会被外界的原因而中断，且断点不固定。进程执行的相对速度不能由进程自己来控制，于是就会导致并发进程在共享资源的时出现与时间有关的错误。
>
> 临界区：并发进程中与共享变量有关的程序段都称为临界区。
>
> P操作：申请资源操作。
>
> V操作：释放资源操作。
> 

`原子操作`
> "原子操作(atomic operation)是不需要synchronized"，这是多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切 换到另一个线程）-- from baidubaike
>
> [原子操作](https://blog.csdn.net/just_kong/article/details/99289539) 有例子
> 上面的第一个不加锁程序肯定是最不推荐使用的，因为它的执行结果都不正确。第二个程序是使用的常规锁来解决问题，结果正确，但是耗时较久。第三个程序使用的是C++11引入的原子数据类型，使用它程序结果正确，在运行速度上也比加锁的版本快很多。所以，在我们平常写程序的过程中，推荐使用C++11引入的原子变量。
>
> Q：什么时候使用原子操作？
>
> 在多线程并发的条件下，所有不是原子性的操作需要保证原子性时，都需要进行原子操作处理
>
> ```c
> long count = 0;
> void func()
> {
>   count++;
> }
> ```
>
> 如果有n个线程同时执行这段代码，所有线程执行完后，count的值不一定等于n。因为count++不是一个原子操作，编译成汇编代码，如下所示：
>
> ```assembly
> MOV  eax, [count] # 先将 count所在内存的值加载到寄存器；
> INC  eax # 将寄存器的值自增1 -> 
>          # 此时cpu调度将此线程中断，并执行完其它线程后，再将此线程调度执行，会出错
> MOV [count], eax # 将寄存器中的值写回内存
> ```
>
> 

`ftok`

> [linux ftok（）函数](https://www.cnblogs.com/joeblackzqq/archive/2011/05/31/2065161.html)
>
> 系统建立IPC通讯（如消息队列、共享内存时）必须指定一个ID值。通常情况下，该id值通过`ftok`函数得到。
> `ftok`原型如下：
>
> ```c
> key_t ftok( char * fname, int id )
> //fname就时你指定的文件名(该文件必须是存在而且可以访问的)，id是子序号，虽然为int，但是只有8个比特被使用(0-255)。
> //当成功执行的时候，一个key_t值将会被返回，否则 -1 被返回。
> ```
>

#### 系统V共享内存

> 1. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
> 2. 因为多个进程可以同时操作，所以需要进行同步。
> 3. 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
>
> ```c
> #include <sys/shm.h>
> /*当用shmget函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。
> 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1*/
> int shmget(key_t key, size_t size, int flag);
> 
> /*当一段共享内存被创建以后，它并不能被任何进程访问。必须使用shmat函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。
> 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1*/
> void *shmat(int shm_id, const void *addr, int flag);
> 
> /*shmdt函数是用来断开shmat建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。
> 断开与共享内存的连接：成功返回0，失败返回-1*/
> int shmdt(void *addr);
> 
> /*shmctl函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是IPC_RMID（从系统中删除该共享内存）。
> 控制共享内存的相关信息：成功返回0，失败返回-1*/
> int shmctl(int shm_id, int cmd, struct shmid_ds *buf);
> ```
>
> ```shell
> sudo gcc server.c -o server;sudo gcc client.c  -o client
> ```
> Output:
> ```shell
> Client Get the Key:2050097857
> ***************************************
> *                 IPC                 *
> *    Input r to send data to server.  *
> *    Input q to quit.                 *
> ***************************************
> Please input command: r
> Data to send: Hello Share memory!
> Please input command: Do not appect space?
> Wrong input!
> Please input command: r
> Data to send: 123456789 4
> Please input command: q
> 
> Server Get the Key:2050097857
> Hello
> 123456789
> ```

补充
> [来自：Linux环境进程间通信（五）共享内存（下）](https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html)
>
> 进程间需要共享的数据被放在一个叫做`IPC`共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。系统V共享内存通过`shmget`获得或创建一个`IPC`共享内存区域，并返回相应的标识符。内核在保证`shmget`获得或创建一个共享内存区，初始化该共享内存区相应的`shmid_kernel`结构注同时，还将在特殊文件系统`shm`中，创建并打开一个同名文件，并在内存中建立起该文件的相应`dentry`及`inode`结构，新打开的文件不属于任何一个进程（任何进程都可以访问该共享内存区）。所有这一切都是系统调用`shmget`完成的。
>
> `shmid_kernel`是共享内存区域中非常重要的一个数据结构，它是存储管理和文件系统结合起来的桥梁，定义如下：
>
> ```c
> struct shmid_kernel /* private to the kernel */
> {   
>     struct kern_ipc_perm    shm_perm;
>     struct file *       shm_file;
>     int         id;
>     unsigned long       shm_nattch;
>     unsigned long       shm_segsz;
>     time_t          shm_atim;
>     time_t          shm_dtim;
>     time_t          shm_ctim;
>     pid_t           shm_cprid;
>     pid_t           shm_lprid;
> };
> ```
>
> 在创建了一个共享内存区域后，还要将它映射到进程地址空间，系统调用`shmat()`完成此项功能。由于在调用`shmget()`时，已经创建了文件系统`shm`中的一个同名文件与共享内存区域相对应，因此，调用`shmat()`的过程相当于映射文件系统`shm`中的同名文件过程，原理与`mmap()`大同小异。
>
> **系统V共享内存限制**
>
> 在/proc/sys/kernel/目录下，记录着系统V共享内存的一下限制，如一个共享内存区的最大字节数shmmax，系统范围内最大共享内存区标识符数shmmni等，可以手工对其调整，但不推荐这样做。
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ ll /proc/sys/kernel/ | grep shm
> -rw-r--r-- 1 root root 0 5月   9 14:53 shmall
> -rw-r--r-- 1 root root 0 5月   9 14:53 shmmax
> -rw-r--r-- 1 root root 0 6月  10 17:16 shmmni
> -rw-r--r-- 1 root root 0 6月  10 17:16 shm_next_id
> -rw-r--r-- 1 root root 0 6月  10 17:16 shm_rmid_forced
> ```
>
> 

`IPC_CREATE|(0x666)`

> [Linux进程间通信——使用共享内存](<https://blog.csdn.net/ljianhui/article/details/10253345>)
>
> 共享内存的权限标志与文件的读写权限一样，举例来说，`0644`,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。
>
> 优点：我们可以看到使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。
>
> 缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段来进行进程间的同步工作。

#### 共享内存

上述共享内存是系统V共享内存[来自：Linux环境进程间通信（五）共享内存（下）](https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html)，其实还有另一种方式，这里补充一下。

> [Linux环境进程间通信（五）共享内存（上）](<https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html>)
>
> 这是一个不错的文章，还没看。

Q: 共享内存的使用实现原理（必考必问，然后共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？）



### 多线程

> [C++ 多线程](<https://www.runoob.com/cplusplus/cpp-multithreading.html>)
>
> **可移植操作系统接口**（英语：Portable Operating System Interface，缩写为**`POSIX`**）
>
> `pthread_create`是类Unix操作系统（Unix、Linux、Mac OS X等）的创建线程的函数。它的功能是创建线程（实际上就是确定调用该线程函数的入口点），在线程创建以后，就开始运行相关的线程函数。
>
> ```c++
> #include <pthread.h>
> int pthread_create(pthread_t *tidp, //指向线程标识符指针。
>              const pthread_attr_t *attr,//指定线程属性对象，也可以使用默认值 NULL
>              void *(*start_rtn)(void*),//线程运行函数起始地址，一旦线程被创建就会执行
>              void *arg);//运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。
> 
> void pthread_exit( void * value_ptr );
> //一个线程可以隐式的退出，也可以显式的调用pthread_exit函数来退出。
> ```
>
> ```c++
> #include <iostream>
> #include <cstdlib>
> #include <pthread.h>
> #include <unistd.h>
> 
> using namespace std;
> 
> #define NUM_THREADS     5
> 
> void *PrintHello(void *threadid)
> {  
>     // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取
>     sleep(3); // 添加sleep 假装同步
>     int tid = *((int*)threadid);
>     cout << "Hello Runoob! thread ID, " << tid << endl;
>     pthread_exit(NULL); //每个函数都有个这个
> }
> 
> int main ()
> {
>     pthread_t threads[NUM_THREADS];
>     int indexes[NUM_THREADS];// 用数组来保存i的值
>     int rc;
>     int i;
>     for( i=0; i < NUM_THREADS; i++ ){      
>            cout << "main() : Create thread, " << i;
>            indexes[i] = i; //先保存i的值 传入的时候必须强制转换为void* 类型，即无类型指针        
>            rc = pthread_create(&threads[i], NULL, PrintHello, (void *)&(indexes[i]));
>               cout << " indexes: " << indexes[i] << " threads[i]: " << threads[i] << endl;
>            if (rc){
>               cout << "Error:Create Thread Failed," << rc << endl;
>               exit(-1);
>            }
> 	}
> pthread_exit(NULL);
> }
> ```
>
> output:
>
> ```shell
> main() : Create thread, 0 indexes: 0threads[i]: 140680432002816 # 0x‭07FF2B72D2700‬
> main() : Create thread, 1 indexes: 1threads[i]: 140680423610112 # 0x0‭7FF2B6AD1700‬
> main() : Create thread, 2 indexes: 2threads[i]: 140680415217408 # 0x‭07FF2B62D0700‬
> main() : Create thread, 3 indexes: 3threads[i]: 140680406824704 # 0x0‭7FF2B5ACF700‬
> main() : Create thread, 4 indexes: 4threads[i]: 140680398432000 # 0x0‭7FF2B52CE700‬
> Hello Runoob! thread ID, 0
> Hello Runoob! thread ID, 3
> Hello Runoob! thread ID, 1
> Hello Runoob! thread ID, 2
> Hello Runoob! thread ID, 4
> # 每相邻线程pthread_t相差0x801000是地址空间嘛
> ```
>
> 在`sleep`时用`pstree -p`查看
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ pstree -p 9223
> test.o(9223)─┬─{test.o}(9224)
>           ├─{test.o}(9226)
>           ├─{test.o}(9227)
>           ├─{test.o}(9228)
>           └─{test.o}(9229) # 如何设置线程名字呢？
> ```
>
> 之后有个想线程传递参数，我没run，因为原理很简单，就是将`pthread_create`的最后一个参数传入，就是一个指针，到线程内部在解析指针。

下面说说`pthread_attr_t`和线程的深度知识
>[pthread_attr_t 线程属性(一)](https://www.cnblogs.com/jacklikedogs/p/4030048.html)
>
>```c++
>#include <pthread.h>
>int pthread_attr_init(pthread_attr_t *attr);   // 初始化后使用，使用后还要进行去除初始化
>int pthread_attr_destroy(pthread_attr_t *attr);// 若成功返回0，若失败返回-1。
>
>typedef struct
>{
>       int                     detachstate;     // 线程的分离状态
>       int                     schedpolicy;     // 线程调度策略
>       struct sched_param      schedparam;      // 线程的调度参数
>       int                     inheritsched;    // 线程的继承性
>       int                     scope;           // 线程的作用域
>       size_t                  guardsize;       // 线程栈末尾的警戒缓冲区大小
>       int                     stackaddr_set;
>       void *                  stackaddr;       // 线程栈的位置
>       size_t                  stacksize;       // 线程栈的大小
>}pthread_attr_t;
>```
>
>**分离状态**
>
>线程的分离状态决定一个线程以什么样的方式来终止自己。在默认情况下线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束。只有当`pthread_join() `函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。
>
>通俗的说也就是：我们知道一般我们要等待(`pthread_join`)一个线程的结束，主要是想知道它的结束状态但是如果有一些线程的终止态我们压根就不想知道，那么就可以使用“分离”属性，那么我们就无须等待管理，只要线程自己结束了，自己释放资源就可以咯！这样更方便！
>
>```c++
>#include <pthread.h>
>int pthread_attr_getdetachstate(const pthread_attr_t * attr, int * detachstate);
>int pthread_attr_setdetachstate(pthread_attr_t * attr, int detachstate);
>```
>
>设置的时候可以有两种选择：
>
>- `detachstate`参数为：`PTHREAD_CREATE_DETACHED`     分离状态启动
>- `detachstate`参数为：`PTHREAD_CREATE_JOINABLE`    正常启动线程
>
>在任何一个时间点上，线程是可结合的（`joinable`），或者是分离的（`detached`）。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。[线程分离状态的理解](<https://blog.csdn.net/jobbofhe/article/details/52252736>)
>
>[以分离状态创建线程](<https://blog.csdn.net/pbymw8iwm/article/details/6721038>)
>
>```c++
>#include<pthread.h>
>void *child_thread(void *arg)
>{
>	printf(“child thread run!\n”);
>}
>
>int main(int argc,char *argv[ ])
>{
>      pthread_ttid;
>      pthread_attr_tattr;
>      pthread_attr_init(&attr);
>      pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);
>      pthread_create(&tid,&attr,fn,arg);
>      pthread_attr_destroy(&attr);
>      sleep(1);
>}
>```
>
>所以说这个“分离”与不分离，其实只对资源有用，在使用过程中对调度其实没多大影响？
>
>**线程的继承性**
>
>```c++
>#include <pthread.h>
>int pthread_attr_getinheritsched(const pthread_attr_t *attr,int *inheritsched);
>int pthread_attr_setinheritsched(pthread_attr_t *attr,int inheritsched); //若成功返回0，若失败返回-1。
>/*PTHREAD_INHERIT_SCHED： 新的线程继承创建线程的策略和参数！
>  PTHREAD_EXPLICIT_SCHED：新的线程继承策略和参数来自于schedpolicy和schedparam属性中显式设置的调度信息！*/
>```
>
>
>
>**线程的调度策略**
>
>```c++
>int pthread_attr_getschedpolicy(const pthread_attr_t*attr,int *policy);
>int pthread_attr_setschedpolicy(pthread_attr_t *attr,intpolicy);
>```
>
>调度策略可能的值是先进先出（`SCHED_FIFO`）、轮转法（`SCHED_RR`）,或其它（`SCHED_OTHER`）。
>
>- `SCHED_FIFO`策略允许一个线程运行直到有更高优先级的线程准备好，或者直到它自愿阻塞自己。在`SCHED_FIFO`调度策略下，当有一个线程准备好时，除非有平等或更高优先级的线程已经在运行，否则它会很快开始执行。
>- `SCHED_RR`(轮循)策略是基本相同的，不同之处在于：如果有一个`SCHED_RR`策略的线程执行了超过一个固定的时期*(*时间片间隔*)*没有阻塞，而另外的`SCHED_RR`或`SCHBD_FIPO`策略的相同优先级的线程准备好时，运行的线程将被抢占以便准备好的线程可以执行。
>- 当有`SCHED_FIFO`或`SCHED_RR`策赂的线程在一个条件变量上等持或等持加锁同一个互斥量时，它们将以优先级顺序被唤醒。即，如果一个低优先级的`SCHED_FIFO`线程和一个高优先织的`SCHED_FIFO`线程都在等待锁相同的互斥且，则当互斥量被解锁时，**高优先级线程将总是被首先解除阻塞**。
>
>**线程的调度参数**
>
>```c++
>int pthread_attr_getschedparam(const pthread_attr_t*attr,struct sched_param *param);
>int pthread_attr_setschedparam(pthread_attr_t *attr,conststruct sched_param *param);
>```
>
>`sched_param`详细可参见：[struct sched_param 结构体](<https://blog.csdn.net/weixin_38239856/article/details/82117600>)
>
>[linux线程调度策略](<https://www.cnblogs.com/charlieroro/p/12133100.html>) 这是一篇非常好的关于线程调度的资料，翻译自[shed](<https://man7.org/linux/man-pages/man7/sched.7.html>)
>
>**线程的作用域**
>
>```c++
>/*线程的作用域*/
>int tscope;
>ret = pthread_attr_getscope(&attr,&tscope);
>if(ret){
>    cout << "getscope Failed!" << endl;
>    exit(-1);
>}
>
>if(tscope == PTHREAD_SCOPE_PROCESS) cout << "PTHREAD_SCOPE_PROCESS" << endl;
>if(tscope == PTHREAD_SCOPE_SYSTEM)  cout << "PTHREAD_SCOPE_SYSTEM" << endl;
>```
>
>```shell
>PTHREAD_SCOPE_SYSTEM
>```
>
>**线程堆栈的大小**
>
>```c++
>/*线程堆栈的大小*/
>size_t stacksize;
>ret = pthread_attr_getstacksize(&attr,&stacksize);
>if(ret){
>    cout << "getstacksize Failed!" << endl;
>    exit(-1);
>}
>
>cout << "getstacksize:" << stacksize << endl;//8,388,608 = 0x800000 = 8M
>```
>
>这个是堆栈大小，是堆的还是栈的？
>
>**线程堆栈的地址**
>
>堆栈地址函数没用好。输出都是0。先这样吧后续有需求再补充。

#### 堆栈大小

从上面的例子也可以看出来，至少这个机器是`8M`的栈空间或者用命令`ulimit -s`查看（`ulimit -a`可以查看所有信息），至于堆嘛：

> [进程空间分配和堆栈大小](https://www.cnblogs.com/ladawn/p/8449399.html) 
>
> 堆的大小理论上大概等于进程虚拟空间大小-内核虚拟内存大小。windows下，进程的高位`2G`留给内核，低位`2G`留给用户，所以进程堆的大小小于`2G`。Linux下，进程的高位`1G`留给内核，低位`3G`留给用户，所以进程堆大小小于`3G`。

#### 线程阻塞

> [linux系统排查线程阻塞问题](<https://blog.csdn.net/qq_42609381/article/details/81412266>)
>
> ```shell
> [root@Joe ~]# pstack 11694 > one
> [root@Joe ~]# pstack 11694 > two
> [root@Joe ~]# diff one two
> ```
>
> ```shell
> [root@Joe ~]# strace -p 11694
> ```

`pstack`

> [pstack命令](<https://man.linuxde.net/pstack>) 有例子，这里我就不粘贴了，和之前看到的很像。
>
> 可显示每个进程的栈跟踪。`pstack` 命令必须由相应进程的属主或 `root` 运行。可以使用 `pstack` 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 `PID`。
>
> [pstack使用和原理](https://www.cnblogs.com/mumuxinfei/p/4366708.html) 有个小总结
>
> 对`pstack`的作用, 大致可以归纳如下:
> 　1). 查看线程数(比`pstree`, 包含了详细的堆栈信息)
>        2). 能简单验证是否按照预定的调用顺序/调用栈执行
> 　3). 采用高频率多次采样使用时, 能发现程序当前的阻塞在哪里, 以及性能消耗点在哪里?
> 　4). 能反映出疑似的死锁现象(多个线程同时在wait lock, 具体需要进一步验证)

`strace`

> strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。
>
> 链接：https://www.jianshu.com/p/d6686cb72f68

## 僵尸进程

> [孤儿进程与僵尸进程总结](https://www.cnblogs.com/Anker/p/3271773.html)
>
> ```c++
> 
> ```
>
> 
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ sudo gcc orphan.c -o test.o
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ ./test.o 
> I am father process.
> I am the child process.
> pid: 14705      ppid:14704
> I will sleep five seconds.
> father process is  exited.
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ pid: 14705    ppid:1 
> # 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
> child process is exited.
> ```

### 查看僵尸进程

>  [linux杀死僵尸进程](https://www.cnblogs.com/mayhh/p/9968428.html)
>
>  `top`命令配合左上角的`zombie`就可以确定是否有僵尸进程了。
>
>  ```shell
>  # -A 参数列出所有进程 -o 自定义输出字段
>  (base) ejior@ejior-XPS-8930:~$ ps -A -ostat,ppid,pid,cmd,user |grep -e '^[Zz]' # grep -e<范本样式> 或 --regexp=<范本样式> : 指定字符串做为查找文件内容的样式。
>  Zs     389   392 [bundle] <defunct>          git
>  ZN   23717 27925 [debconf-communi] <defunct> ejior
>  
>  (base) ejior@ejior-XPS-8930:~$ ps aux | grep Zs |  grep -v grep
>  git       1606  0.0  0.0      0     0 ?        Zs   17:43   0:00 [bundle] <defunct>
>  ejior     3205  0.0  0.0  44188  4828 ?        Ss   5月09   8:20 dbus-daemon --fork --session --address=unix:abstract=/tmp/dbus-Z0PsNZsTnh
>  
>  $ kill -HUP <僵尸进程父ID> # 杀死僵尸进程
>  ```
>
>  

## 死锁

死锁是怎么产生的

死锁检测

> [linux死锁检测的一种思路](https://www.cnblogs.com/mumuxinfei/p/4365697.html) 有代码：`D:\00-personal\05-code\dead_lock_sample`
>
> 这个用拓扑排序解决死锁，很新颖嘛。



1. CPU的执行方式
2. 代码中遇到进程阻塞，进程僵死，内存泄漏，程序崩溃等情况怎么排查。

## 协程


1. 有没有了解过协程？说下协程和线程的区别？

2. 堆是线程共有还是私有，堆是进程共有还是私有，栈呢

   

   
## 内存空间分布
   c++进程内存空间分布（注意各部分的内存地址谁高谁低，注意栈从高道低分配，堆从低到高分配）

   > [c++进程内存空间分布](<https://blog.csdn.net/xiaozuo2017/article/details/81452869>)
   >
   > 内存分布分为5个部分，从高地址到低地址依次为 栈区（stack），堆区（heap），未初始化数据段（uninitialized data），初始化数据段（initialize data），代码段（text）。
   >
   > ![](http://www.geeksforgeeks.org/wp-content/uploads/Memory-Layout.gif)
   >
   > ![hehe](https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153)
   >
   > 

   ## PCB

> 为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为[进程控制块](https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97/7205297)（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。
>
> [PCB（进程控制块）讲解](<https://blog.csdn.net/IT_10/article/details/89819138>)
>
> PCB：进程控制块，实际是一个结构体，放在`sched.h`文件中，Linux下可以通过`whereis sched.h`命令查看具体路径

## ELF

ELF是什么？其大小与程序中全局变量的是否初始化有什么关系（注意.bss段）

> [ELF 格式详解（一）](<https://zhuanlan.zhihu.com/p/73114831>)
>
> **ELF 全称 “Executable and Linkable Format”，即可执行可链接文件格式，目前常见的Linux、 Android可执行文件、共享库（.so）、目标文件（ .o）以及Core 文件（吐核）均为此格式。**
>
> 

> [Linux ELF: ELF文件结构简单梳理](<https://www.jianshu.com/p/dd5aec5826da>)
>
> ![](https://upload-images.jianshu.io/upload_images/807220-5cdd5e1bd1b2c8ce?imageMogr2/auto-orient/strip|imageView2/2/w/906/format/webp)
>
> 这个文章说有四种，除了静/动态链接库和可执行文件，还有一个`core dump`文件。而
>
> [ELF文件格式解析](<https://blog.csdn.net/dddxxxx/article/details/80347610>)
>
> 说只有知道3种即可。另外这个文章还说“我们主要是以Shared Object File(.so)为重点分析对象，因为我们在**逆向**`APK`中会遇到的绝大部分都是此类文件”

### ELF视图

> ELF文件格式提供了两种视图，分别是链接视图和执行视图。链接视图是以节（section）为单位，执行视图是以段（segment）为单位。链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。
>
> 文件可以分为四个部分：
>
> - ELF header： 描述整个文件的组织。
> - Program Header Table: 描述文件中的各种segments，用来告诉系统如何创建进程映像的。
> - sections 或者 segments：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件，也就是说，在链接阶段，我们可以忽略program header table来处理此文件，在运行阶段可以忽略section header table来处理此程序（所以很多加固手段删除了section header table）。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。
> - Section Header Table: 包含了文件各个section的属性信息，我们都将结合例子来解释。
>
> ![示意图](https://img-blog.csdn.net/20160521110434854)
>
> **程序头部表**（Program Header Table），如果存在的话，告诉系统如何创建进程映像。
> **节区头部表**（Section Header Table）包含了描述文件节区的信息，比如大小、偏移等。

上面都是粘贴的，有些概念理解不深，下面文章用`readelf`命令看了看其他的文件，是windows环境下的，我这里用Linux环境模拟下:

```shell
(base) ejior@ejior-XPS-8930:~/huangyue2$ ll
总用量 12
-rw-rw-r--  1 ejior ejior   85 7月   2 16:18 test.cpp
(base) ejior@ejior-XPS-8930:~/huangyue2$ g++ test.cpp -c -o t.o
(base) ejior@ejior-XPS-8930:~/huangyue2$ g++ test.cpp -o t
(base) ejior@ejior-XPS-8930:~/huangyue2$ ar crsv libt.a t.o
a - t.o
(base) ejior@ejior-XPS-8930:~/huangyue2$ g++ test.cpp -fPIC -shared -Wl,-soname,libt.so -o libtet.so.0.1
(base) ejior@ejior-XPS-8930:~/huangyue2$ ll
总用量 40
-rw-rw-r--  1 ejior ejior 1646 7月   2 16:25 libt.a # 静态库 
-rwxrwxr-x  1 ejior ejior 8120 7月   2 16:27 libtet.so.0.1* # 动态库
-rwxrwxr-x  1 ejior ejior 8608 7月   2 16:23 t* # 可执行程序
-rw-rw-r--  1 ejior ejior   85 7月   2 16:18 test.cpp # 源文件
-rw-rw-r--  1 ejior ejior 1504 7月   2 16:23 t.o # 目标文件
```

**命令详解参考[GCC](#compile)**

`readelf`

```shell
(base) ejior@ejior-XPS-8930:~/huangyue2$ readelf --help
用法：readelf <选项> elf-文件
 显示关于 ELF 格式文件内容的信息
 Options are:
  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I
  -h --file-header       Display the ELF file header
  -l --program-headers   Display the program headers
     --segments          An alias for --program-headers
  -S --section-headers   Display the sections' header
     --sections          An alias for --section-headers
  -g --section-groups    Display the section groups
  -t --section-details   Display the section details
  -e --headers           Equivalent to: -h -l -S
  -s --syms              Display the symbol table
     --symbols           An alias for --syms
```



> **`readelf`命令，**一般用于查看ELF格式的文件信息，常见的文件如在Linux上的可执行文件，动态库(\*.so)或者静态库(\*.a) 等包含ELF格式的文件。

#### 可执行程序

```shell
(base) ejior@ejior-XPS-8930:~/huangyue2$ readelf -h t # 可执行程序
ELF 头：
  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  版本:                              1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              EXEC (可执行文件) # 标记
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：               0x400430
  程序头起点：          64 (bytes into file)
  Start of section headers:          6624 (bytes into file)
  标志：             0x0
  本头的大小：       64 (字节)
  程序头大小：       56 (字节)
  Number of program headers:         9
  节头大小：         64 (字节)
  节头数量：         31
  字符串表索引节头： 28
```

#### 目标文件.o

```shell
(base) ejior@ejior-XPS-8930:~/huangyue2$ readelf -h t.o
ELF 头：
  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  版本:                              1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              REL (可重定位文件)
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：               0x0
  程序头起点：          0 (bytes into file)
  Start of section headers:          672 (bytes into file)
  标志：             0x0
  本头的大小：       64 (字节)
  程序头大小：       0 (字节)
  Number of program headers:         0
  节头大小：         64 (字节)
  节头数量：         13
  字符串表索引节头： 10
```

#### 静态库.a

```shell
(base) ejior@ejior-XPS-8930:~/huangyue2$ readelf -h libt.a

文件：libt.a(t.o)
ELF 头：
  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  版本:                              1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              REL (可重定位文件)
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：               0x0
  程序头起点：          0 (bytes into file)
  Start of section headers:          672 (bytes into file)
  标志：             0x0
  本头的大小：       64 (字节)
  程序头大小：       0 (字节)
  Number of program headers:         0
  节头大小：         64 (字节)
  节头数量：         13
  字符串表索引节头： 10
```

#### 动态库

```shell
(base) ejior@ejior-XPS-8930:~/huangyue2$ readelf -h libtet.so.0.1 
ELF 头：
  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  版本:                              1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              DYN (共享目标文件)
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：               0x5a0
  程序头起点：          64 (bytes into file)
  Start of section headers:          6264 (bytes into file)
  标志：             0x0
  本头的大小：       64 (字节)
  程序头大小：       56 (字节)
  Number of program headers:         7
  节头大小：         64 (字节)
  节头数量：         29
  字符串表索引节头： 26
```

奇怪，这里`ELF64`对应位是`1`，参考中的图片`ELF32`也对应`1`

![](https://img-blog.csdn.net/20160521110756954)

> [ELF文件结构描述](https://www.cnblogs.com/linhaostudy/p/8855238.html)
>
> ELF文件头结构及相关常数被定义在“`/usr/include/elf.h`”，因为ELF文件在各种平台下都通用，ELF文件有32位版本和64位版本的ELF文件的文件头内容是一样的，只不过有些成员的大小不一样。它的文件图也有两种版本：分别叫**“`Elf32_Ehdr`”**和**“`Elf64_Ehdr`”**。






3. 使用过哪些进程间通讯机制，并详细说明（重点）

4. 多线程和多进程的区别（重点 面试官最最关心的一个问题，必须从CPU调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）

5. 信号：列出常见的信号，信号怎么处理？

6. i++是否原子操作？并解释为什么？？？？？？？

7. 说出你所知道的各类linux系统的各类同步机制（重点），什么是死锁？如何避免死锁（每个技术面试官必问）

8. 列举说明linux系统的各类异步机制

9. exit() _exit()的区别？

10. 如何实现守护进程？

11. linux的内存管理机制是什么？

12. linux的任务调度机制是什么？

13. 标准库函数和系统调用的区别？

14. 补充一个坑爹坑爹坑爹坑爹的问题：系统如何将一个信号通知到进程？（这一题哥没有答出来）

15. [多线程有什么好处？](https://www.cnblogs.com/liuyangofficial/p/7072595.html)

    



# Linux系统

1. linux的各种命令 给你场景让你解决
2. Linux了解么，查看进程状态ps，查看cpu状态 top。查看占用端口的进程号netstat grep
3. Linux的cpu 100怎么排查，top jstack，日志，gui工具
4. Linux操作系统了解么
5. 怎么查看CPU负载，怎么查看一个客户下有多少进程
6. Linux内核是怎么实现定时器的
7. gdb怎么查看某个线程

## core

1. core dump有没有遇到过，gdb怎么调试
2. linux如何设置core文件生成

### [Linux Core Dump](https://www.cnblogs.com/hazir/p/linxu_core_dump.html) ★

> 当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做**Core Dump**（中文有的翻译成“核心转储”)。
>
> 当程序运行过程中**异常终止**或**崩溃**时会发生 core dump，但什么具体的情景程序会发生异常终止或崩溃，例如我们使用 `kill -9` 命令杀死一个进程会发生 core dump 吗？实验证明是不能的，那么什么情况会产生呢？
>
> Linux 中信号是一种异步事件处理的机制，每种信号对应有其默认的操作，你可以在 **这里** 查看 Linux 系统提供的信号以及默认处理。默认操作主要包括
>
> - 忽略该信号（Ingore）、
> - 暂停进程（Stop）、
> - 终止进程（Terminate）、
> - 终止并发生core dump（core）等
>
> 以下列出几种信号，它们在发生时会产生 core dump:
>
> | Signal  | Action | Comment                                                      |
> | ------- | ------ | ------------------------------------------------------------ |
> | SIGQUIT | Core   | Quit from keyboard                                           |
> | SIGILL  | Core   | Illegal Instruction                                          |
> | SIGABRT | Core   | Abort signal from [abort](http://man7.org/linux/man-pages/man3/abort.3.html) |
> | SIGSEGV | Core   | Invalid memory reference                                     |
> | SIGTRAP | Core   | Trace/breakpoint trap                                        |
>
> 当然不仅限于上面的几种信号。这就是为什么我们使用 `Ctrl+z` 来挂起一个进程或者 `Ctrl+C` 结束一个进程均不会产生 core dump，因为前者会向进程发出 **SIGTSTP** 信号，该信号的默认操作为暂停进程（Stop Process）；后者会向进程发出**SIGINT** 信号，该信号默认操作为终止进程（Terminate Process）。同样上面提到的 `kill -9` 命令会发出 **SIGKILL** 命令，该命令默认为终止进程。而如果我们使用 `Ctrl+\` 来终止一个进程，会向进程发出 **SIGQUIT** 信号，默认是会产生 core dump 的。还有其它情景会产生 core dump， 如：程序调用 `abort()` 函数、访存错误、非法指令等等。

[Linux生成core文件、core文件路径设置](<https://blog.csdn.net/u011417820/article/details/71435031>)

### 设置core文件大小

```shell
ulimit -a # 列出所有资源的限制
ulimit -c # core 文件； 0: 程序错误不产生；1024:文件大于1024K不产生
ulimit -c fileSize # 设置core文件大小。 尽量将这个文件大小设置得大一些，程序崩溃时生成Core文件大小即为程序运行时占用的内存大小。可能发生堆栈溢出的时候，占用更大的内存
```

> 用上面命令只会对当前的终端环境有效，如果想需要永久生效，可以修改文件 `/etc/security/limits.conf`文件，关于此文件的设置参看 **这里** 。增加一行:

### 设置core文件的名称和文件路径

- 默认生成路径：输入可执行文件运行命令的同一路径下
- 默认生成名字：默认命名为core。新的core文件会覆盖旧的core文件

#### 设置`pid`作为文件扩展名

```shell
echo "1" > /proc/sys/kernel/core_uses_pid  # 修改 /proc/sys/kernel/core_uses_pid 文件内容为: 1
# or
sysctl -w kernel.core_uses_pid=1 kernel.core_uses_pid = 1
```

1：添加`pid`作为扩展名，生成的`core`文件名称为`core.pid`
0：不添加`pid`作为扩展名，生成的`core`文件名称为`core`

#### 控制core文件保存位置和文件名格式

```shell
echo "/corefile/core-%e-%p-%t" > /proc/sys/kernel/core_pattern
# or 
sysctl -w kernel.core_pattern=/corefile/core.%e.%p.%s.%E
```

就是修改这两个文件的内容，注意`echo`命令会将文件全部内容替换成`""`里的内容。

> `error200703 -bash: /proc/sys/kernel/core_uses_pid:` 权限不够
>
> [Why is editing core_pattern restricted?](https://unix.stackexchange.com/questions/343275/why-is-editing-core-pattern-restricted)
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue2/cmd$ sudo bash -c 'echo "1" > /proc/sys/kernel/core_uses_pid' # 记得单引号
> [sudo] ejior 的密码： 
> (base) ejior@ejior-XPS-8930:~/huangyue2/cmd$ cat /proc/sys/kernel/core_uses_pid
> 1
> ```

### 测试是否能生成core文件

```shell
kill -s SIGSEGV $$ # 运行后链接就断了
```

> [linux之kill命令详解](https://www.cnblogs.com/lhdz_bj/p/12963873.html)
>
> **`11) SIGSEGV`**:试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.这是**默认会导致进程流产的信号**

### 调试core

```shell
gdb ./test core-test-31639-1593754742
Core was generated by `./test'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004004e6 in main ()
(gdb) n
The program is not being run.
(gdb) run
Starting program: /home/ejior/huangyue2/cmd/test
```





1. linux如何设置开机自启动
2. linux用过哪些命令、工具

## 程序性能检测工具

1. 用过哪些工具检测程序性能，如何定位性能瓶颈的地方

### Perf

[Perf – Linux下的系统性能调优工具，第 1 部分](https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/)

> Perf 是用来进行软件性能分析的工具。
>
> 通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。它不但可以分析指定应用程序的性能问题 (per thread)，也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。
>
> 安装[使用参考二](<https://blog.csdn.net/FZeroTHero/article/details/102909990>)
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ perf
> 程序“perf”尚未安装。 您可以使用以下命令安装：
> sudo apt install linux-tools-common
> sudo apt install linux-tools-4.15.0-99-generic
> ```
>
> **Perf list，perf 事件**
>
> 使用 `perf list` 命令可以列出所有能够触发 `perf` 采样点的事件，可以将它们划分为三类：
>
> - Hardware Event 是由 `PMU` 硬件产生的事件，比如 cache 命中，当您需要了解程序对硬件特性的使用情况时，便需要对这些事件进行采样；
>
> - Software Event 是内核软件产生的事件，比如进程切换，tick 数等 ;
>
> - Tracepoint event 是内核中的静态 tracepoint 所触发的事件，这些 tracepoint 用来判断程序运行期间内核的行为细节，比如 slab 分配器的分配次数等。
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ sudo gcc -o t1 -g test.c
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ sudo perf stat ./t1
> 
>  Performance counter stats for './t1':
> 
>         170.253031      task-clock (msec)         #    0.833 CPUs utilized          
>                  1      context-switches          #    0.006 K/sec                  
>                  0      cpu-migrations            #    0.000 K/sec                  
>                 42      page-faults               #    0.247 K/sec                  
>        737,784,977      cycles                    #    4.333 GHz                    
>        550,715,493      instructions              #    0.75  insn per cycle         
>        110,133,503      branches                  #  646.881 M/sec                  
>              6,183      branch-misses             #    0.01% of all branches        
> 
>        0.204348976 seconds time elapsed
> ```
>
> 程序 `t1` 是一个 CPU bound 型，因为`task-clock (msec)` 接近 1。对 `t1` 进行调优应该要找到热点 ( 即最耗时的代码片段 )，再看看是否能够提高热点代码的效率。
>
> 缺省情况下，除了 `task-clock (msec)` 之外，`perf stat` 还给出了其他几个最常用的统计信息：
>
> - `task-clock (msec)`：CPU 利用率，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO
>
> - `Context-switches`：进程切换次数，记录了程序运行过程中发生了多少次进程切换，频繁的进程切换是应该避免的。
>
> - `CPU-migrations`：表示进程 `t1 `运行过程中发生了多少次 CPU 迁移，即被调度器从一个 CPU 转移到另外一个 CPU 上运行
>
> - `Cycles`：处理器时钟，一条机器指令可能需要多个 cycles
>
> - `Instructions`: 机器指令数目；`IPC insn per cycle`：是 Instructions/Cycles 的比值，该值越大越好，说明程序充分利用了处理器的特性
>
> -  `branch-misses` [记一次perf branch-misses 100%的调试经历](https://www.cnblogs.com/haoxing990/p/12811260.html)
>
> 还有一些我这里没有，就没列举，以下跑了下之前测试虚函数指针的程序，改程序有较多的`printf`。
>
> ```shell
>  Performance counter stats for './test.o':
>           0.766077      task-clock (msec)         #    0.015 CPUs utilized          
>                  1      context-switches          #    0.001 M/sec                  
>                  0      cpu-migrations            #    0.000 K/sec                  
>                109      page-faults               #    0.142 M/sec                  
>          3,276,602      cycles                    #    4.277 GHz                    
>          3,339,796      instructions              #    1.02  insn per cycle         
>            589,429      branches                  #  769.412 M/sec                  
>             17,233      branch-misses             #    2.92% of all branches        
>        0.052286059 seconds time elapsed
> ```
>
> 从`CPUs utilized`可以看出，这应该是一个`IO`型的程序。
>
> **perf top**出来的信息，和参考差距有点大。
>
> **使用 `perf record`, 解读 report ** 比如说您已经断定目标程序计算量较大，也许是因为有些代码写的不够精简。那么面对长长的代码文件，究竟哪几行代码需要进一步修改呢？这便需要使用 `perf record` 记录单个函数级别的统计信息，并使用` perf report `来显示统计结果。
>
> `error 1`:
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ sudo perf record – e cpu-clock ./t1
> Workload failed: No such file or directory
> # 这个错误没解决，我尝试将可执行文件从挂载区弄到非挂载区，可以生成perf.data文件但是依然报错，并且不能打开
> ```
>
> [可能解决方案：BCOS区块链性能分析工具的安装和使用perf+火焰图](<https://blog.csdn.net/weixin_43946212/article/details/100161808>)
>
> 

[Perf – Linux下的系统性能调优工具，第 2 部分](https://www.ibm.com/developerworks/cn/linux/l-cn-perf2/)

> `perf top，perf stat, perf record` 等也是内核调优的基本手段
>
> 

[系统级性能分析工具perf的介绍与使用](https://www.cnblogs.com/arnoldlu/p/6241297.html)



[系统级性能分析工具 — Perf](https://blog.csdn.net/zhangskd/article/details/37902159)

[perf Examples](<http://www.brendangregg.com/perf.html>)



1. `netstat tcpdump ipcs ipcrm` （如果这四个命令没听说过或者不能熟练使用，基本上可以回家，通过的概率较小 ^_^ ，这四个命令的熟练掌握程度基本上能体现面试者实际开发和调试程序的经验)


## `netstat`

> [Linux netstat命令详解](https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html)
>
> `netstat `命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (`multicast` Memberships) 等等。
>
> 从整体上看，netstat的输出结果可以分为两个部分：
>
> - 一个是Active Internet connections，称为有源TCP连接，其中"Recv-Q"和"Send-Q"指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。
>
> - 另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。
>
> **列出所有端口 `netstat -a | more`**
>
> **列出所有 tcp 端口 `netstat -at`**
>
> **列出所有 udp 端口 `netstat -au`**
>
> **列出所有处于监听状态的 Sockets** ：**只显示监听端口**`netstat -l | more`；只列出所有监听 tcp 端口 `netstat -lt`；**只列出所有监听 udp 端口 netstat -lu**；**只列出所有监听 UNIX 端口 netstat -lx**
>
> **显示所有端口的统计信息 netstat -s**；**显示 TCP 或 UDP 端口的统计信息 netstat -st 或 -su**
>
> 。。。

## `tcpdump `

> [tcpdump网络调试](https://www.cnblogs.com/roverliang/p/11435219.html)
>
> 用简单的话来定义`tcpdump`，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。` tcpdump`可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。
>
> ```shell
> $ sudo tcpdump # 默认启动
> ```
>
> 普通情况下，直接启动`tcpdump`将监视第一个网络接口上所有流过的数据包。
>
> ```shell
> $ tcpdump host 210.27.48.1 # 可以指定ip,例如截获所有210.27.48.1 的主机收到的和发出的所有的数据包
> ```
>
> 

## `ifconfig`

> [Linux网卡命名enp3s0说明](https://segmentfault.com/a/1190000006078381)
>
> ```shell
> en - Ethernet
> sl - serial line IP
> wl - wlan
> ww - wwan
> ```

## ` ipcs ipcrm`

> [Linux ipcs命令与ipcrm命令的用法详解](<https://www.jb51.net/article/40805.htm>)
>
> `linux/uinx`上提供关于一些进程间通信方式的信息，包括共享内存，消息队列，信号
>
> ```shell
> $ ipcs -a  # 是默认的输出信息 打印出当前系统中所有的进程间通信方式的信息
> $ ipcs -m  # 打印出使用共享内存进行进程间通信的信息
> $ ipcs -q  # 打印出使用消息队列进行进程间通信的信息
> $ ipcs -s  # 打印出使用信号进行进程间通信的信息
> ```
>
> `ipcrm`移除一个消息对象。或者共享内存段，或者一个信号集，同时会将与ipc对象相关链的数据也一起移除。当然，只有超级管理员，或者ipc对象的创建者才有这项权利啦。
>
> ```shell
> $ ipcrm -M shmkey  # 移除用shmkey创建的共享内存段
> $ ipcrm -m shmid   # 移除用shmid标识的共享内存段
> $ ipcrm -Q msgkey  # 移除用msqkey创建的消息队列
> $ ipcrm -q msqid   # 移除用msqid标识的消息队列
> $ ipcrm -S semkey  # 移除用semkey创建的信号
> $ ipcrm -s semid   # 移除用semid标识的信号
> ```
>
> 





1. `cpu` 内存 硬盘 等等与系统性能调试相关的命令必须熟练掌握，设置修改权限 tcp网络状态查看 各进程状态 抓包相关等相关命令 必须熟练掌握



1. awk sed需掌握

## `awk sed`

> [linux awk命令详解](https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html)
>
> `awk`是一个强大的文本分析工具，相对于`grep`的查找，`sed`的编辑，`awk`在其对数据分析并生成报告时，显得尤为强大。
>
> [Linux sed 命令](<https://www.runoob.com/linux/linux-comm-sed.html>)
>
> Linux sed 命令是利用脚本来处理文本文件。

1. `gdb`调试相关的经验，会被问到

[面试问我，创建多少个线程合适？我该怎么说](<https://www.jianshu.com/p/f30ee2346f9f>)



# Compile

## g++ 常用

> [GCC编译基础](<https://zhuanlan.zhihu.com/p/151219726?utm_source=wechat_session&utm_medium=social&utm_oi=65958932643840>)
>
> 一个完整的C++编译过程（例如g++ a.cpp生成可执行文件），总共包含以下四个过程：
>
> - 编译预处理，也称预编译，可以使用命令`g++ -E`执行；
> - 编译，可以使用`g++ -S`执行
> - 汇编，可以使用`as` 或者`g++ -c`执行
> - 链接，可以使用`g++ xxx.o xxx.so xxx.a`执行

解释上述`ELF`中的程序：

```sh
(base) ejior@ejior-XPS-8930:~/huangyue2$ ll
-rw-rw-r--  1 ejior ejior   85 7月   2 16:18 test.cpp
(base) ejior@ejior-XPS-8930:~/huangyue2$ g++ test.cpp -c -o t.o # 
(base) ejior@ejior-XPS-8930:~/huangyue2$ g++ test.cpp -o t
(base) ejior@ejior-XPS-8930:~/huangyue2$ ar crsv libt.a t.o # KEY1
a - t.o
(base) ejior@ejior-XPS-8930:~/huangyue2$ g++ test.cpp -fPIC -shared -Wl,-soname,libt.so -o libtet.so.0.1 # KEY2
(base) ejior@ejior-XPS-8930:~/huangyue2$ ll
-rw-rw-r--  1 ejior ejior 1646 7月   2 16:25 libt.a
-rwxrwxr-x  1 ejior ejior 8120 7月   2 16:27 libtet.so.0.1*
-rwxrwxr-x  1 ejior ejior 8608 7月   2 16:23 t*
-rw-rw-r--  1 ejior ejior   85 7月   2 16:18 test.cpp
-rw-rw-r--  1 ejior ejior 1504 7月   2 16:23 t.o
```

- `KEY1:` 使用`ar`命令进行“归档”（.a的实质是将文件进行打包）

  - `r` 替换归档文件中已有的文件或加入新文件 (必要)
  - `c` 不在必须创建库的时候给出警告
  - `s` 创建归档索引
  - `v` 输出详细信息

- `KEY2:` 使用`g++ -shared` 命令指定编译生成的是一个动态库

  - `shared`:告诉编译器生成一个动态链接库

  - `-Wl,-soname`:指示生成的动态链接库的别名（这里是`libtest.so`）

  - `-o`:指示实际生成的动态链接库（这里是`libtest.so.0.1`）

  - `-fPIC`

  - - fPIC的全称是 `Position Independent Code`， 用于生成位置无关代码（看不懂没关系，总之加上这个参数，别的代码在引用这个库的时候才更方便，反之，稍不注意就会有各种乱七八糟的报错）。
    - 使用-fPIC选项生成的动态库，是位置无关的。这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针的值，加上一个偏移得到全局变量/函数的地址。
    - 关于PIC参数的详细解读：[点此链接](https://link.zhihu.com/?target=http%3A//blog.sina.com.cn/s/blog_54f82cc201011op1.html)


## gdb







## g++和gcc

> [g++和gcc的相同点和区别](<https://blog.csdn.net/hitwengqi/article/details/8013754>) 有参数详解
>
> `-lpthread` : `-llibrary` 制定编译的时候使用的库。例子用法
>
> ```shell
> gcc -lcurses hello.c # 使用ncurses库编译程序
> ```
>
> 









C++加速命令，属于编译优化，慎用

```c++
#pragma GCC optimize("Ofast")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("avx,avx2,sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native")
#pragma GCC optimize("fast-math")
#pragma GCC optimize("inline")

static const int _ = []() {
	ios::sync_with_stdio(false);
	cin.sync_with_stdio(false);
	cout.sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	return 0;
}();
```

