# REFERENCE

- [linux C++后台开发面试题](<https://zhuanlan.zhihu.com/p/103027724>)
- [知乎：程序员面试，面试官更注重代码量、项目经验还是操作系统、数据结构这种基础课程？两者比例是五五开还是多少？](https://www.zhihu.com/question/264198516)
- [复习参考指北](<https://blog.csdn.net/qq_40840459/category_7280605.html>)
- 

# 操作系统

## 进程和线程

1. 分别的概念 区别 适用范围 它们分别的通讯方式 不同通讯方式的区别优缺点
> [知乎 线程和进程的区别是什么？](<https://www.zhihu.com/question/25532384>)
> 做个简单的比喻：进程=火车，线程=车厢
>
> - 线程在进程下行进（单纯的车厢无法运行）
> - 一个进程可以包含多个线程（一辆火车可以有多个车厢）
> - 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
> - 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
> - 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
> - 进程间不会相互影响，**一个线程挂掉将导致整个进程挂掉**（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
> - 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
> - 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
> - 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

> 线程作为进程的一部分，扮演的角色就是怎么利用中央处理器去运行代码。这其中牵扯到的最重要资源的是中央处理器和其中的寄存器，和线程的栈（stack）。这里想强调的是，线程关注的是中央处理器的运行，而不是内存等资源的管理。

> [操作系统—进程概念](<https://blog.csdn.net/qq_40840459/article/details/80058705>)
>
> **进程与程序**
>
> - 程序：代码段+数据段
> - 进程：代码段+数据段+堆栈+[PCB](#pcb)
>
> 进程是操作系统分配资源的基本单位，也是最小单位。每个进程有自己的独立地址空间和执行状态。 操作系统内核一定要有一个PCB来管理进程。（OS角度）
>
> **进程的状态**
>
> - 运行态：该进程正在运行，即进程正在占用CPU。
> - 就绪态：进程已经具备执行的一切条件，正在等待分配CPU的处理时间片。
> - 等待态：进程正在等待某个事件或某个资源。等待态又分为可中断等待和不可中断等待两种。可中断的等待进程可被信号中断，而不可中断的等待进程不能被信号中断。
> - 停止状态：当进程收到一个`SIGSTOP`信号后，便由运行态进入停止状态，当收到`SIGCONT`信号时又会恢复运行态，该状态主要用于调试。
> - 僵死状态（终止状态）：进程已终止，但其`task_struct `结构仍在内存中。顾名思义，处于这种状态的进程实际是死进程。
>
> ![](https://img-blog.csdn.net/20180423173237921?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODQwNDU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
>
> 



### [进程间通信（IPC）介绍](https://www.cnblogs.com/CheeseZH/p/5264465.html)

这个文章总结的比较全面还有例子。

[bilibili](<https://www.bilibili.com/video/BV1NZ4y1x7VS?p=100>)

> 目前发展到现在，还剩4个比较好的。管道（使用简单）、信号（开销最小）、共享内存映射（无血缘关系的进程）、本地套接字（最稳定）。

#### 管道

> 当一个管道建立时，它会创建两个文件描述符：`fd[0]`为读而打开，`fd[1]`为写而打开
>
> [video：bilibili -101](<https://www.bilibili.com/video/BV1NZ4y1x7VS?p=101>) : 管道实为内核使用环形队列机制，借助内核缓冲区（4K）实现。
>
> 局限性：
>
> - 数据不能自己写自己读
> - 管道的数据不能反复读取，读完就没了
> - 采用半双工
> - 要有血缘关系

这个`main`里的参数有点像，又有点想进程的标准输入输出的参数。有例子：

> ```c++
> #include<stdio.h>
> #include<unistd.h>
> 
> int main()
> {
> int fd[2];  // 两个文件描述符
> pid_t pid;
> char buff[20];
> 	printf("[line:%d] Parent pid:%d\n",__LINE__,getpid());
> 
> if(pipe(fd) < 0)  // 创建管道
>   	printf("Create Pipe Error!\n");
> 
> if((pid = fork()) < 0)  // 创建子进程
>   	printf("Fork Error!\n");
> else if(pid > 0)  // 父进程
> {
> 	printf("Parent pid:%d\n",pid);
>       close(fd[0]); // 关闭读端
>       write(fd[1], "hello world\n", 12);//12就是字符数吧
> }
> else
> {
> 	printf("Children pid:%d\n",pid);
>       close(fd[1]); // 关闭写端
>       read(fd[0], buff, 20);
>       printf("%s", buff);
> }
> 
> return 0;
> }
> ```
> OutPut:
> ```shell
> [line:9] Parent pid:14167 # 这是真正的Parent Thread
> Parent pid:14168 # 这是fork出来那个执行的
> Children pid:0  # 这是fork()的返回值，可参考frok用法
> hello world
> ```
> 还真能实现进程通信，但确实如前所述只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）
>

> [linux编程之pipe()函数](https://www.cnblogs.com/kunhu/p/3608109.html)
> ![pipe](https://images2015.cnblogs.com/blog/323808/201603/323808-20160311094030069-935122142.png)
>
> ```c++
> #include<unistd.h>
> int pipe(int filedes[2]); //返回值：成功，返回0，否则返回-1。参数数组包含pipe使用的两个文件的描述符。fd[0]:读管道，fd[1]:写管道。必须在fork()中调用pipe()，否则子进程不会继承文件描述符。两个进程不共享祖先进程，就不能使用pipe。
> ```
>
> 管道最大的劣势就是没有名字，只能用于有一个共同祖先进程的各个进程之间。FIFO代表先进先出，但它是一个单向数据流，也就是半双工，和管道不同的是：每个FIFO都有一个路径与之关联，从而允许无亲缘关系的进程访问。  

##### 管道的读写特性

> [video:103](<https://www.bilibili.com/video/BV1NZ4y1x7VS?p=103>)
>
> 读管道
>
> - 有数据：正常返回实际读到的数据字节数
> - 无数据：1）管道写端被关闭，read返回0；2）如果没被关闭，read阻塞等待。
>
> 写管道
>
> - 管道读端被关闭，进程异常终止；（可以捕捉`SIGPIPE`信号）
> - 读端未关闭，1）管道已满，write阻塞；2）管道未满，write写入并返回**实际写入字节数**
>
> 用程序实现`ls | wc -l`的功能：
>
> ```c++
> #include<stdio.h>
> #include<unistd.h>
> 
> int main()
> {
>     int fd[2];  // 两个文件描述符
>     pid_t pid;
>     char buff[20];
> 	printf("[line:%d] Parent pid:%d\n",__LINE__,getpid());
> 
>     if(pipe(fd) < 0)  // 创建管道
>         printf("Create Pipe Error!\n");
> 
>     if((pid = fork()) < 0)  // 创建子进程
>         printf("Fork Error!\n");
>     else if(pid > 0)  // 父进程
>     {
> 		printf("Parent pid:%d fd[0]:%d, fd[1]:%d\n",getpid(),fd[0],fd[1]);
>         close(fd[0]); // 关闭读端
> 		dup2(fd[1],STDOUT_FILENO); // 重定向父进程的标准输出
> 		execlp("ls","ls",NULL);
>     }
>     else
>     {
> 		printf("Children pid:%d fd[0]:%d, fd[1]:%d\n",getpid(),fd[0],fd[1]);
>         close(fd[1]); // 关闭写端
> 		dup2(fd[0],STDIN_FILENO);// 重定向子进程的标准输入
> 		execlp("wc","wc","-l",NULL);
>     }
>     return 0; // 结果是打印到终端上的。
> }
> ```
>
> ```shell
> [line:9] Parent pid:11953
> Parent pid:11953 fd[0]:3, fd[1]:4 # KEY 这个3、4应该是文件表述符的第3和4个位置，0是标准输入...
> Children pid:11954 fd[0]:3, fd[1]:4
> 8
> ```
>
> 管道大小可以用`ulimit -a`里面`pipe size            (512 bytes, -p) 8`

#### FIFO 命名管道

> 原型：
>
> ```c++
> #include <sys/stat.h>
> int mkfifo(const char *pathname, mode_t mode);
> // 返回值：成功返回0，出错返回-1。
> // 其中的 mode 参数与open函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。
> ```
>
> FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时**清除数据**，并且“先进先出”。下面的例子演示了使用 FIFO 进行 IPC 的过程：
>
> ```c
> /*write_fifo.c*/
> #include<stdio.h>
> #include<stdlib.h>   // exit
> #include<fcntl.h>    // O_WRONLY
> #include<sys/stat.h>
> #include<time.h>     // time
> 
> int main()
> {
>     int fd;
>     int n, i;
>     char buf[1024];
>     time_t tp;
> 
>     printf("I am %d process.\n", getpid()); // 说明进程ID
> 
>     if((fd = open("../fifo1", O_WRONLY)) < 0) // 以写打开一个FIFO
>     {
>         perror("Open FIFO Failed");
>         exit(1);
>     }
> 
>     for(i=0; i<10; ++i)
>     {
>         time(&tp);  // 取系统当前时间
>         n = sprintf(buf,"Process %d's time is %s",getpid(),ctime(&tp));
>         printf("n: %d, Send message: %s", n, buf); // 打印
>         if(write(fd, buf, n+1) < 0)  // 写入到FIFO中
>         {
>             perror("Write FIFO Failed");
>             close(fd);
>             exit(1);
>         }
>         sleep(1);  // 休眠1秒
>     }
> 
>     close(fd);  // 关闭FIFO文件
>     return 0;
> }
> ```
>
> ```c
> /*read_fifo.c*/
> #include<stdio.h>
> #include<stdlib.h>
> #include<errno.h>
> #include<fcntl.h>
> #include<sys/stat.h>
> 
> int main()
> {
>     int fd;
>     int len;
>     char buf[1024];
> 	
> 	printf("I am %d process.\n", getpid()); // 说明进程ID
> 
>     if(mkfifo("../fifo1", 0666) < 0 && errno!=EEXIST) // 创建FIFO管道
>         perror("Create FIFO Failed\n");
> 
>     if((fd = open("../fifo1", O_RDONLY)) < 0)  // 以读打开FIFO
>     {
>         perror("Open FIFO Failed");
>         exit(1);
>     }
> 
>     while((len = read(fd, buf, 1024)) > 0) // 读取FIFO管道
>         printf("Read message: %s", buf);
> 
>     close(fd);  // 关闭FIFO文件
>     return 0;
> }
> ```
>
> 

`mkfifo`

> [mkfifo函数使用](<https://blog.csdn.net/superywf/article/details/73438465>) `man 3 mkfifo`
>
> `mkfifo()`会依参数`pathname`建立特殊的`FIFO`文件，**该文件必须不存在，创建后文件存在**，
>
> ```shell
> prw-r--r--  1 root  root       0 6月   9 17:09 fifo1|
> ```
>
> 而参数`mode`为该文件的权限`（mode%~umask）`，因此 `umask`值也会影响到`FIFO`文件的权限。

 `error 1: Create FIFO Failed: Operation not permitted`

   >[在共享文件夹里面创建管道mkfifo失败ubuntu](https://www.cnblogs.com/kirk1995/p/6654578.html) 
   >
   >原来是文件系统的问题，window的文件系统不支持管道文件，只要把创建的管道文件路径设为linux的本地文件夹就行了。刚开始我以为是hgfs文件夹权限的问题，于是在网上搜啊，还是没找到更改ubuntu下hgfs文件夹权限的方法，查到的都是说共享文件夹特殊，还是不要动的话。
   >
   >其实是和权限没关系的，就是文件系统问题，所以就算改了也还是不行的。

`errno`

   >[Linux errno详解](https://www.cnblogs.com/Jimmy1988/p/7485133.html) 
   >Linux中系统调用的错误都存储于 `errno`中，`errno`由操作系统维护，存储就近发生的错误，即下一次的错误码会覆盖掉上一次的错误。
   >
   >查看系统中所有的`errno`所代表的含义，可以采用如下的代码：
   >
   >```c++
   >/* Function: obtain the errno string
   >*   char *strerror(int errno)
   >*/
   >
   >#include <stdio.h>
   >#include <string.h>     //for strerror()
   >//#include <errno.h>
   >int main()
   >{
   >    int tmp = 0;
   >    for(tmp = 0; tmp <=256; tmp++)
   >    {
   >        printf("errno: %2d\t%s\n",tmp,strerror(tmp));
   >    }
   >    return 0;
   >}
   >// Linux中，在头文件 /usr/include/asm-generic/errno-base.h 对基础常用errno进行了宏定义：
   >// #define EEXIST      17  /* File exists */
   >```

`perror`

> [C 库函数 - perror()](<https://www.runoob.com/cprogramming/c-function-perror.html>)
>
> C 库函数 **`void perror(const char \*str)`** 把一个描述性错误消息输出到标准错误 `stderr`。首先输出字符串 **`str`**，后跟一个冒号，然后是一个空格。
>
> ```c++
> void perror(const char *str)
> ```
>
> 

##### `fork`的用法：

> [Linux中fork（）函数详解](https://www.cnblogs.com/bastard/archive/2012/08/31/2664896.html)
>
> **fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：**
> 1）在父进程中，fork返回新创建子进程的进程ID；
> 2）在子进程中，fork返回0；
> 3）如果出现错误，fork返回一个负值；
>
> 引用一位网友的话来解释`fpid`的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的`fpid`(p 意味point)指向子进程的进程id,因为子进程没有子进程，所以其`fpid`为0.
>
> 创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。
> 每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过`getpid()`函数获得，还有一个记录父进程pid的变量，可以通过`getppid()`函数获得变量的值。
>
> ```shell
>            2043 
> 			 /   
> 		3224  -> termial 
> 	   /    \
> 	3225    3226 # 上述参考链接例子出的结果
> /
> 3227			   
> ```
>
> 
>
> `nowcode`:最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。[vedio:exec原理](<https://www.bilibili.com/video/BV1NZ4y1x7VS?p=89>) 这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。

##### `fork`底层

> - 分配系统内存（子进程获得父进程数据空间，堆和栈的副本）-> 拷贝父进程信息过去-> 将子进程添加到系统进程列表（任务调度队列）-> `return`；
> - 从fork函数开始以后的代码父子共享

`vfork`

> - `vfork`创建的子进程与父进程共享地址空间。
> - `fork`父子进程交替运行，`vfork`子进程运行，父进程阻塞，直到子进程结束
> - 每个系统上的`vfork`都有问题，建议不要使用

`exec`

```c++
int execl(const char* path, const char* arg, ...);  // 
execl("./a.out","./a.out", NULL); //这个哨兵要加

int execlp(const char* file, const char* arg, ...); // 借助PATH文件 通常是ls\date\cp\cat的命令
execlp("ls","ls","-l","h",NULL); // NULL哨兵 都是带""的， 只有出错才会返回。666
```



##### 进程共享

刚`fork`之后父子相同的是：全局变量、.data、.text、栈、堆、环境变量、用户ID组ID、宿主目录、进程工作目录、信号处理方式。

不同的：进程id、fork返回值、父进程ID、进程运行时间、闹钟、未决信号集

父子共享的是：文件描述符、`mmap`映射区；对于数据，父子进程是读时共享、写时复制。

#### 消息队列

> ```c
> #include <sys/msg.h>
> // 创建或打开消息队列：成功返回队列ID，失败返回-1
> int msgget(key_t key, int flag);
> // 添加消息：成功返回0，失败返回-1
> int msgsnd(int msqid, const void *ptr, size_t size, int flag);
> // 读取消息：成功返回消息数据的长度，失败返回-1
> int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
> // 控制消息队列：成功返回0，失败返回-1
> int msgctl(int msqid, int cmd, struct msqid_ds *buf);
> ```
>
> ```shell
> sudo gcc msg_client.c -o msg_c; sudo gcc msg_server.c  -o msg_s
> ```
>
> ```c
> /*msg_server.c*/
> #include <stdio.h>
> #include <stdlib.h>
> #include <sys/msg.h>
> 
> // 用于创建一个唯一的key
> #define MSG_FILE "/etc/passwd"
> 
> // 消息结构
> struct msg_form {
>  long mtype;
>  char mtext[256];
> };
> 
> int main()
> {
>  int msqid;
>  key_t key;
>  struct msg_form msg;
> 
>  // 获取key值
>  if((key = ftok(MSG_FILE,'z')) < 0)
>  {
>      perror("ftok error");
>      exit(1);
>  }
> 
>  // 打印key值
>  printf("Message Queue - Server key is: %d.\n", key);
> 
>  // 创建消息队列
>  if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
>  {
>      perror("msgget error");
>      exit(1);
>  }
> 
>  // 打印消息队列ID及进程ID
>  printf("My msqid is: %d.\n", msqid);
>  printf("My pid is: %d.\n", getpid());
> 
>  // 循环读取消息
>  for(;;)
>  {
>      msgrcv(msqid, &msg, 256, 888, 0);// 返回类型为888的第一个消息
>      printf("Server: receive msg.mtext is: %s.\n", msg.mtext);
>      printf("Server: receive msg.mtype is: %d.\n", msg.mtype);
> 
>      msg.mtype = 999; // 客户端接收的消息类型
>      sprintf(msg.mtext, "hello, I'm server %d", getpid());
>      msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
>  }
>  return 0;
> }
> ```
> 在两个终端运行
> ```c
> /*msg_client.c*/
> #include <stdio.h>
> #include <stdlib.h>
> #include <sys/msg.h>
> 
> // 用于创建一个唯一的key
> #define MSG_FILE "/etc/passwd"
> 
> // 消息结构
> struct msg_form {
>  long mtype;
>  char mtext[256];
> };
> 
> int main()
> {
>  int msqid;
>  key_t key;
>  struct msg_form msg;
> 
>  // 获取key值
>  if ((key = ftok(MSG_FILE, 'z')) < 0)
>  {
>      perror("ftok error");
>      exit(1);
>  }
> 
>  // 打印key值
>  printf("Message Queue - Client key is: %d.\n", key);
> 
>  // 打开消息队列
>  if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
>  {
>      perror("msgget error");
>      exit(1);
>  }
> 
>  // 打印消息队列ID及进程ID
>  printf("My msqid is: %d.\n", msqid);
>  printf("My pid is: %d.\n", getpid());
> 
>  // 添加消息，类型为888
>  msg.mtype = 888;
>  sprintf(msg.mtext, "hello, I'm client %d", getpid());
>  msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
> 
>  // 读取类型为999的消息
>  msgrcv(msqid, &msg, 256, 999, 0);
>  printf("Client: receive msg.mtext is: %s.\n", msg.mtext);
>  printf("Client: receive msg.mtype is: %d.\n", msg.mtype);
>  return 0;
> }
> ```
>
> ```
> Message Queue - Client key is: 2047025538.
> My msqid is: 0.
> My pid is: 27106.
> Client: receive msg.mtext is: hello, I'm server 27053.
> Client: receive msg.mtype is: 999.
> ```
>
> ```
> Message Queue - Server key is: 2047025538.
> My msqid is: 0.
> My pid is: 27625.
> Server: receive msg.mtext is: hello, I'm client 27632.
> Server: receive msg.mtype is: 888.
> ```
>
> 

#### 信号量

> **信号量（semaphore）**与已经介绍过的 `IPC` 结构不同，它是一个**计数器**。信号量用于实现进程间的互斥与同步，**而不是用于存储进程间通信数据**。
>
> 1. 信号量用于进程间同步，若要在进程间传递数据需要结合**共享内存**。
> 2. 信号量基于操作系统的 `PV `操作，程序对信号量的操作都是原子操作。
> 3. ...
>
> ```c
> #include <sys/sem.h>
> // 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1
> int semget(key_t key, int num_sems, int sem_flags);
> // 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1
> int semop(int semid, struct sembuf semoparray[], size_t numops);
> // 控制信号量的相关信息
> int semctl(int semid, int sem_num, int cmd, ...);
> // 在semop函数中，sembuf结构
> struct sembuf
> {
>     short sem_num; // 信号量组中对应的序号，0～sem_nums-1
>     short sem_op;  // 信号量值在一次操作中的改变量
>     short sem_flg; // IPC_NOWAIT, SEM_UNDO
> }
> ```
>
> 在`semctl`函数中的命令有多种，这里就说两个常用的：
>
> - `SETVAL`：用于初始化信号量为一个已知的值。所需要的值作为联合semun的val成员来传递。在信号量第一次使用之前需要设置信号量。
> - `IPC_RMID`：删除一个信号量集合。**如果不删除信号量，它将继续在系统中存在**，即使程序已经退出，它可能在你下次运行此程序时引发问题，**而且信号量是一种有限的资源**。
>
> ```c
> #include<stdio.h>
> #include<stdlib.h>
> #include<sys/sem.h>
> 
> // 联合体，用于semctl初始化
> union semun
> {
>     int              val; /*for SETVAL*/
>     struct semid_ds *buf;
>     unsigned short  *array;
> };
> 
> // 初始化信号量
> int init_sem(int sem_id, int value)
> {
>     union semun tmp;
>     tmp.val = value;
>     if(semctl(sem_id, 0, SETVAL, tmp) == -1)
>     {
>         perror("Init Semaphore Error");
>         return -1;
>     }
>     return 0;
> }
> 
> // P操作:
> //    若信号量值为1，获取资源并将信号量值-1
> //    若信号量值为0，进程挂起等待
> int sem_p(int sem_id)
> {
>     struct sembuf sbuf;
>     sbuf.sem_num = 0; /*序号*/
>     sbuf.sem_op = -1; /*P操作*/
>     sbuf.sem_flg = SEM_UNDO;/*这个UNDO应该是值啥也不做等待信号量释放的意思吧*/
> 
>     if(semop(sem_id, &sbuf, 1) == -1)
>     {
>         perror("P operation Error");
>         return -1;
>     }
>     return 0;
> }
> 
> // V操作：
> //    释放资源并将信号量值+1
> //    如果有进程正在挂起等待，则唤醒它们
> int sem_v(int sem_id)
> {
>     struct sembuf sbuf;
>     sbuf.sem_num = 0; /*序号*/
>     sbuf.sem_op = 1;  /*V操作*/
>     sbuf.sem_flg = SEM_UNDO;
> 
>     if(semop(sem_id, &sbuf, 1) == -1)
>     {
>         perror("V operation Error");
>         return -1;
>     }
>     return 0;
> }
> 
> // 删除信号量集
> int del_sem(int sem_id)
> {
>     union semun tmp;
>     if(semctl(sem_id, 0, IPC_RMID, tmp) == -1)
>     {
>         perror("Delete Semaphore Error");
>         return -1;
>     }
>     return 0;
> }
> 
> 
> int main()
> {
>     int sem_id;  // 信号量集ID
>     key_t key;
>     pid_t pid;
> 
>     // 获取key值
>     if((key = ftok(".", 'z')) < 0)
>     {
>         perror("ftok error");
>         exit(1);
>     }
> 
>     // 创建信号量集，其中只有一个信号量
>     if((sem_id = semget(key, 1, IPC_CREAT|0666)) == -1)
>     {
>         perror("semget error");
>         exit(1);
>     }
> 	
> 	printf("Create Semaphore number:%d\n",sem_id);
>     // 初始化：初值设为0资源被占用，因此是子进程先执行，因为原本是0，子进程释放后才是1，sem_p操作才有效
>     init_sem(sem_id, 0);
> 
>     if((pid = fork()) == -1)//PS.从这个例子也很容易看出来，fork之后，子进程是接着父进程的点继续执行的
>         perror("Fork Error");
>     else if(pid == 0) /*子进程*/
>     {
>         sleep(2);
>         printf("Process child: pid=%d\n", getpid());
>         sem_v(sem_id);  /*释放资源*/
>     }
>     else  /*父进程*/
>     {
>         sem_p(sem_id);   /*等待资源*/
>         printf("Process father: pid=%d\n", getpid());
>         sem_v(sem_id);   /*释放资源*/
>         del_sem(sem_id); /*删除信号量集*/
>     }
>     return 0;
> }
> ```
>
> Output:
>
> ```shell
> Create Semaphore number:458766
> Process child: pid=3764
> Process father: pid=3763 # 父进程等待信号量，因此在子进程之后运行
> ```
>
> 

[*10 June 2020*] 

对于上述程序，还是有些细节没有深究，包括*信号量是一个有限资源，有多少？*等。



`PV操作`

> [操作系统——PV操作](<https://blog.csdn.net/ws_Ando/article/details/83501519>)
>
> PV操作概念：操作系统中的一种同步机制，实现对于并发进程中临界区的管理。
>
> 并发进程分为两种：
>
> ①无交互的并发进程：每个进程是相互独立的，谁也不影响谁，基本不会用到PV操作。
>
> ②有交互的并发进程：多个进程共享资源，一个进程的运行，有可能会被外界的原因而中断，且断点不固定。进程执行的相对速度不能由进程自己来控制，于是就会导致并发进程在共享资源的时出现与时间有关的错误。
>
> 临界区：并发进程中与共享变量有关的程序段都称为临界区。
>
> P操作：申请资源操作。
>
> V操作：释放资源操作。
> 

`原子操作`
> "原子操作(atomic operation)是不需要synchronized"，这是多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切 换到另一个线程）-- from baidubaike
>
> [原子操作](https://blog.csdn.net/just_kong/article/details/99289539) 有例子
> 上面的第一个不加锁程序肯定是最不推荐使用的，因为它的执行结果都不正确。第二个程序是使用的常规锁来解决问题，结果正确，但是耗时较久。第三个程序使用的是C++11引入的原子数据类型，使用它程序结果正确，在运行速度上也比加锁的版本快很多。所以，在我们平常写程序的过程中，推荐使用C++11引入的原子变量。
>
> Q：什么时候使用原子操作？
>
> 在多线程并发的条件下，所有不是原子性的操作需要保证原子性时，都需要进行原子操作处理
>
> ```c
> long count = 0;
> void func()
> {
> count++;
> }
> ```
>
> 如果有n个线程同时执行这段代码，所有线程执行完后，count的值不一定等于n。因为count++不是一个原子操作，编译成汇编代码，如下所示：
>
> ```assembly
> MOV  eax, [count] # 先将 count所在内存的值加载到寄存器；
> INC  eax # 将寄存器的值自增1 -> 
>       # 此时cpu调度将此线程中断，并执行完其它线程后，再将此线程调度执行，会出错
> MOV [count], eax # 将寄存器中的值写回内存
> ```
>

i++是否原子操作？并解释为什么？

> **i++分为三个阶段：**内存到寄存器；寄存器自增；回内存；这三个阶段中间都可以被中断分离开.

`ftok`

> [linux ftok（）函数](https://www.cnblogs.com/joeblackzqq/archive/2011/05/31/2065161.html)
>
> 系统建立`IPC`通讯（如消息队列、共享内存时）必须指定一个ID值。通常情况下，该id值通过`ftok`函数得到。
> `ftok`原型如下：
>
> ```c
> key_t ftok( char * fname, int id )
> //fname就时你指定的文件名(该文件必须是存在而且可以访问的)，id是子序号，虽然为int，但是只有8个比特被使用(0-255)。
> //当成功执行的时候，一个key_t值将会被返回，否则 -1 被返回。
> ```
>

#### 共享内存

> [system v和posix的共享内存对比 & 共享内存位置](https://www.cnblogs.com/charlesblc/p/6261469.html)
>
> 有两类基本的API函数用于在进程间共享内存:System v和POSIX.  （当然，还有mmap，属于POSIX的）
>
> ![](https://images2015.cnblogs.com/blog/899685/201701/899685-20170108104623112-1571452506.png)

> [两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。](<https://blog.csdn.net/Al_xin/article/details/38602093>) 算是原理？
>
> 对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据[1]：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。

##### 系统V共享内存

> 1. 共享内存是最快的一种 `IPC`，因为进程是直接对内存进行存取。
> 2. 因为多个进程可以同时操作，所以需要进行同步。
> 3. 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
>
> ```c
> #include <sys/shm.h>
> /*当用shmget函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。
> 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1*/
> int shmget(key_t key, size_t size, int flag);
> 
> /*当一段共享内存被创建以后，它并不能被任何进程访问。必须使用shmat函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。
> 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1*/
> void *shmat(int shm_id, const void *addr, int flag);
> 
> /*shmdt函数是用来断开shmat建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。
> 断开与共享内存的连接：成功返回0，失败返回-1*/
> int shmdt(void *addr);
> 
> /*shmctl函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是IPC_RMID（从系统中删除该共享内存）。
> 控制共享内存的相关信息：成功返回0，失败返回-1*/
> int shmctl(int shm_id, int cmd, struct shmid_ds *buf);
> ```
>
> ```shell
> sudo gcc server.c -o server;sudo gcc client.c  -o client
> ```
> Output:
> ```shell
> Client Get the Key:2050097857
> ***************************************
> *                 IPC                 *
> *    Input r to send data to server.  *
> *    Input q to quit.                 *
> ***************************************
> Please input command: r
> Data to send: Hello Share memory!
> Please input command: Do not appect space?
> Wrong input!
> Please input command: r
> Data to send: 123456789 4
> Please input command: q
> 
> Server Get the Key:2050097857
> Hello
> 123456789
> ```

补充
> [来自：Linux环境进程间通信（五）共享内存（下）](https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html)
>
> 进程间需要共享的数据被放在一个叫做`IPC`共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。系统V共享内存通过`shmget`获得或创建一个`IPC`共享内存区域，并返回相应的标识符。内核在保证`shmget`获得或创建一个共享内存区，初始化该共享内存区相应的`shmid_kernel`结构注同时，还将在特殊文件系统`shm`中，创建并打开一个同名文件，并在内存中建立起该文件的相应`dentry`及`inode`结构，新打开的文件不属于任何一个进程（任何进程都可以访问该共享内存区）。所有这一切都是系统调用`shmget`完成的。
>
> `shmid_kernel`是共享内存区域中非常重要的一个数据结构，它是存储管理和文件系统结合起来的桥梁，定义如下：
>
> ```c
> struct shmid_kernel /* private to the kernel */
> {   
>     struct kern_ipc_perm    shm_perm;
>     struct file *       shm_file;
>     int         id;
>     unsigned long       shm_nattch;
>     unsigned long       shm_segsz;
>     time_t          shm_atim;
>     time_t          shm_dtim;
>     time_t          shm_ctim;
>     pid_t           shm_cprid;
>     pid_t           shm_lprid;
> };
> ```
>
> 在创建了一个共享内存区域后，还要将它映射到进程地址空间，系统调用`shmat()`完成此项功能。由于在调用`shmget()`时，已经创建了文件系统`shm`中的一个同名文件与共享内存区域相对应，因此，调用`shmat()`的过程相当于映射文件系统`shm`中的同名文件过程，原理与`mmap()`大同小异。
>
> **系统V共享内存限制**
>
> 在/proc/sys/kernel/目录下，记录着系统V共享内存的一下限制，如一个共享内存区的最大字节数shmmax，系统范围内最大共享内存区标识符数shmmni等，可以手工对其调整，但不推荐这样做。
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ ll /proc/sys/kernel/ | grep shm
> -rw-r--r-- 1 root root 0 5月   9 14:53 shmall
> -rw-r--r-- 1 root root 0 5月   9 14:53 shmmax
> -rw-r--r-- 1 root root 0 6月  10 17:16 shmmni
> -rw-r--r-- 1 root root 0 6月  10 17:16 shm_next_id
> -rw-r--r-- 1 root root 0 6月  10 17:16 shm_rmid_forced
> ```
>
> 

`IPC_CREATE|(0x666)`

> [Linux进程间通信——使用共享内存](<https://blog.csdn.net/ljianhui/article/details/10253345>)
>
> 共享内存的权限标志与文件的读写权限一样，举例来说，`0644`,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。
>
> 优点：我们可以看到使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。
>
> 缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段来进行进程间的同步工作。

##### posix共享内存

上述共享内存是系统V共享内存[来自：Linux环境进程间通信（五）共享内存（下）](https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html)，其实还有另一种方式，这里补充一下。

> [Linux环境进程间通信（五）共享内存（上）](<https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html>)
>
> ```c++
> /*-------------map_normalfile1.c-----------*/
> #include <sys/mman.h>
> #include <sys/types.h>
> #include <fcntl.h>
> #include <unistd.h>
> #include <stdio.h>
> #include <string.h>
> #include <stdlib.h>
> 
> typedef struct{
> 	char name[4];
> 	int  age;
> }people;
> 
> int main(int argc, char** argv) // map a normal file as shared mem:
> {
> 	int fd,i;
> 	people *p_map;
> 	char temp;
> 
> 	fd = open("./test_mmap",O_RDWR|O_CREAT|O_TRUNC,0644);
> 
> 	/*lseek(fd,sizeof(people)*5 - 1,SEEK_SET);
> 	write(fd,"",1); // 这是在扩展文件大小吧 video中有以下两个方法：
> 	
> 	
> 	lseek(fd,10,SEEK_END);
> 	write(fd,"\0",1);
> 
> 	or:*/
> 	ftruncate(fd, sizeof(people) * 5);
> 	int len = lseek(fd,0,SEEK_END); // 获取文件长度
> 
> 	p_map = (people*) mmap( NULL, len , PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0 );
> 	
> 	if(p_map == MAP_FAILED){
> 		perror("mmap error");
> 		exit(-1);
> 	}
> 	printf("[Line:%d]: address: %p\n",__LINE__,p_map); // KEY 1
> 	
> 	close( fd );
> 	temp = 'a';
> 	for(i=0; i<10; i++)
> 	{
> 		temp += 1;
> 		memcpy( ( *(p_map+i) ).name, &temp, 2 );
> 		( *(p_map+i) ).age = 20 + i;
> 	}
> 	printf(" initialize over \n ");
> 	
> 	sleep(10);
> 	
> 	if( munmap( p_map, sizeof(people) * 10 ) > 0)
> 		printf( "umap ok \n" );
> 	
> 	return 0;
> }
> ```
>
> - `KEY1`输出是`[Line:40]: address: 0x7fcc47e09000`看起来像是栈。
>
> ![](https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/image001.gif)

Q: 共享内存的使用实现原理（必考必问，然后共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？）

[video:113](<https://www.bilibili.com/video/BV1NZ4y1x7VS?p=113>)

> 存储映射I/O
>
> ```c++
> void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
> /*创建共享内存映射
> addr:指定映射区的首地址，通常是NULL，由系统自动分配
> length: 映射区大小 <= 实际文件的大小
> prot: 映射区读写属性PROT_READ| PROT_WRITE
> flags: 共享区的属性| MAP_SHARED MAP_PREVIATE
> fd: 用于创建共享内存映射的文件描述符
> offset: 偏移 4K 的整数倍*/
> ```
>
> **注意事项：**
>
> - 文件大小是0，1）传入非零，出“总线错误”；2）传入零，出“参数错误”
> - 读写属性为只读(`RDONLY`)，出“参数错误”
> - 文件描述符用过之后可以直接关闭。
> - 被映射那个文件需要有读权限，不然连这个大小都没法知道，我怎么创建映射区大小？

#### 套接字SOCKET



### 多线程

> [C++ 多线程](<https://www.runoob.com/cplusplus/cpp-multithreading.html>)
>
> **可移植操作系统接口**（英语：Portable Operating System Interface，缩写为**`POSIX`**）
>
> `pthread_create`是类Unix操作系统（Unix、Linux、Mac OS X等）的创建线程的函数。它的功能是创建线程（实际上就是确定调用该线程函数的入口点），在线程创建以后，就开始运行相关的线程函数。
>
> ```c++
> #include <pthread.h>
> int pthread_create(pthread_t *tidp, //指向线程标识符指针。
>              const pthread_attr_t *attr,//指定线程属性对象，也可以使用默认值 NULL
>              void *(*start_rtn)(void*),//线程运行函数起始地址，一旦线程被创建就会执行
>              void *arg);//运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。
> 
> void pthread_exit( void * value_ptr );
> //一个线程可以隐式的退出，也可以显式的调用pthread_exit函数来退出。
> ```
>
> ```c++
> #include <iostream>
> #include <cstdlib>
> #include <pthread.h>
> #include <unistd.h>
> 
> using namespace std;
> 
> #define NUM_THREADS     5
> 
> void *PrintHello(void *threadid)
> {  
>     // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取
>     sleep(3); // 添加sleep 假装同步
>     int tid = *((int*)threadid);
>     cout << "Hello Runoob! thread ID, " << tid << endl;
>     pthread_exit(NULL); //每个函数都有个这个
> }
> 
> int main ()
> {
>     pthread_t threads[NUM_THREADS];
>     int indexes[NUM_THREADS];// 用数组来保存i的值
>     int rc;
>     int i;
>     for( i=0; i < NUM_THREADS; i++ ){      
>            cout << "main() : Create thread, " << i;
>            indexes[i] = i; //先保存i的值 传入的时候必须强制转换为void* 类型，即无类型指针        
>            rc = pthread_create(&threads[i], NULL, PrintHello, (void *)&(indexes[i]));
>               cout << " indexes: " << indexes[i] << " threads[i]: " << threads[i] << endl;
>            if (rc){
>               cout << "Error:Create Thread Failed," << rc << endl;
>               exit(-1); // 退出进程
>            }
> 	}
> pthread_exit(NULL);
> }
> ```
>
> output:
>
> ```shell
> main() : Create thread, 0 indexes: 0threads[i]: 140680432002816 # 0x‭07FF2B72D2700‬
> main() : Create thread, 1 indexes: 1threads[i]: 140680423610112 # 0x0‭7FF2B6AD1700‬
> main() : Create thread, 2 indexes: 2threads[i]: 140680415217408 # 0x‭07FF2B62D0700‬
> main() : Create thread, 3 indexes: 3threads[i]: 140680406824704 # 0x0‭7FF2B5ACF700‬
> main() : Create thread, 4 indexes: 4threads[i]: 140680398432000 # 0x0‭7FF2B52CE700‬
> Hello Runoob! thread ID, 0
> Hello Runoob! thread ID, 3
> Hello Runoob! thread ID, 1
> Hello Runoob! thread ID, 2
> Hello Runoob! thread ID, 4
> # 每相邻线程线程号pthread_t相差0x801000是地址空间嘛
> ```
>
> 在`sleep`时用`pstree -p`查看
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ pstree -p 9223
> test.o(9223)─┬─{test.o}(9224)
>           ├─{test.o}(9226)
>           ├─{test.o}(9227)
>           ├─{test.o}(9228)
>           └─{test.o}(9229) # 如何设置线程名字呢？
> ```
>
> 之后有个想线程传递参数，我没run，因为原理很简单，就是将`pthread_create`的最后一个参数传入，就是一个指针，到线程内部在解析指针。

下面说说`pthread_attr_t`和线程的深度知识
>[pthread_attr_t 线程属性(一)](https://www.cnblogs.com/jacklikedogs/p/4030048.html)
>
>```c++
>#include <pthread.h>
>int pthread_attr_init(pthread_attr_t *attr);   // 初始化后使用，使用后还要进行去除初始化
>int pthread_attr_destroy(pthread_attr_t *attr);// 若成功返回0，若失败返回-1。
>
>typedef struct
>{
>       int                     detachstate;     // 线程的分离状态
>       int                     schedpolicy;     // 线程调度策略
>       struct sched_param      schedparam;      // 线程的调度参数
>       int                     inheritsched;    // 线程的继承性
>       int                     scope;           // 线程的作用域
>       size_t                  guardsize;       // 线程栈末尾的警戒缓冲区大小
>       int                     stackaddr_set;
>       void *                  stackaddr;       // 线程栈的位置
>       size_t                  stacksize;       // 线程栈的大小
>}pthread_attr_t;
>```
>
>**分离状态**
>
>线程的分离状态决定一个线程以什么样的方式来终止自己。在默认情况下线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束。只有当`pthread_join() `函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。
>
>通俗的说也就是：我们知道一般我们要等待(`pthread_join`)一个线程的结束，（这个过程是阻塞的）主要是想知道它的结束状态但是如果有一些线程的终止态我们压根就不想知道，那么就可以使用“分离”属性，那么我们就无须等待管理，只要线程自己结束了，自己释放资源就可以咯！这样更方便！
>
>```c++
>#include <pthread.h>
>int pthread_attr_getdetachstate(const pthread_attr_t * attr, int * detachstate);
>int pthread_attr_setdetachstate(pthread_attr_t * attr, int detachstate);
>```
>
>设置的时候可以有两种选择：
>
>- `detachstate`参数为：`PTHREAD_CREATE_DETACHED`     分离状态启动
>- `detachstate`参数为：`PTHREAD_CREATE_JOINABLE`    正常启动线程
>
>在任何一个时间点上，线程是可结合的（`joinable`），或者是分离的（`detached`）。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。[线程分离状态的理解](<https://blog.csdn.net/jobbofhe/article/details/52252736>)
>
>[以分离状态创建线程](<https://blog.csdn.net/pbymw8iwm/article/details/6721038>)
>
>```c++
>#include<pthread.h>
>void *child_thread(void *arg)
>{
>	printf(“child thread run!\n”);
>}
>
>int main(int argc,char *argv[ ])
>{
>      pthread_ttid;
>      pthread_attr_tattr;
>      pthread_attr_init(&attr);
>      pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);
>      pthread_create(&tid,&attr,fn,arg);
>      pthread_attr_destroy(&attr);
>      sleep(1);
>}
>```
>
>所以说这个“分离”与不分离，其实只对资源有用，在使用过程中对调度其实没多大影响？
>
>**线程的继承性**
>
>```c++
>#include <pthread.h>
>int pthread_attr_getinheritsched(const pthread_attr_t *attr,int *inheritsched);
>int pthread_attr_setinheritsched(pthread_attr_t *attr,int inheritsched); //若成功返回0，若失败返回-1。
>/*PTHREAD_INHERIT_SCHED： 新的线程继承创建线程的策略和参数！
>  PTHREAD_EXPLICIT_SCHED：新的线程继承策略和参数来自于schedpolicy和schedparam属性中显式设置的调度信息！*/
>```
>
>
>
>**线程的调度策略**
>
>```c++
>int pthread_attr_getschedpolicy(const pthread_attr_t*attr,int *policy);
>int pthread_attr_setschedpolicy(pthread_attr_t *attr,intpolicy);
>```
>
>调度策略可能的值是先进先出（`SCHED_FIFO`）、轮转法（`SCHED_RR`）,或其它（`SCHED_OTHER`）。
>
>- `SCHED_FIFO`策略允许一个线程运行直到有更高优先级的线程准备好，或者直到它自愿阻塞自己。在`SCHED_FIFO`调度策略下，当有一个线程准备好时，除非有平等或更高优先级的线程已经在运行，否则它会很快开始执行。
>- `SCHED_RR`(轮循)策略是基本相同的，不同之处在于：如果有一个`SCHED_RR`策略的线程执行了超过一个固定的时期*(*时间片间隔*)*没有阻塞，而另外的`SCHED_RR`或`SCHBD_FIPO`策略的相同优先级的线程准备好时，运行的线程将被抢占以便准备好的线程可以执行。
>- 当有`SCHED_FIFO`或`SCHED_RR`策赂的线程在一个条件变量上等持或等持加锁同一个互斥量时，它们将以优先级顺序被唤醒。即，如果一个低优先级的`SCHED_FIFO`线程和一个高优先织的`SCHED_FIFO`线程都在等待锁相同的互斥且，则当互斥量被解锁时，**高优先级线程将总是被首先解除阻塞**。
>
>**线程的调度参数**
>
>```c++
>int pthread_attr_getschedparam(const pthread_attr_t*attr,struct sched_param *param);
>int pthread_attr_setschedparam(pthread_attr_t *attr,conststruct sched_param *param);
>```
>
>`sched_param`详细可参见：[struct sched_param 结构体](<https://blog.csdn.net/weixin_38239856/article/details/82117600>)
>
>[linux线程调度策略](<https://www.cnblogs.com/charlieroro/p/12133100.html>) 这是一篇非常好的关于线程调度的资料，翻译自[shed](<https://man7.org/linux/man-pages/man7/sched.7.html>)
>
>**线程的作用域**
>
>```c++
>/*线程的作用域*/
>int tscope;
>ret = pthread_attr_getscope(&attr,&tscope);
>if(ret){
>    cout << "getscope Failed!" << endl;
>    exit(-1);
>}
>
>if(tscope == PTHREAD_SCOPE_PROCESS) cout << "PTHREAD_SCOPE_PROCESS" << endl;
>if(tscope == PTHREAD_SCOPE_SYSTEM)  cout << "PTHREAD_SCOPE_SYSTEM" << endl;
>```
>
>```shell
>PTHREAD_SCOPE_SYSTEM
>```
>
>**线程堆栈的大小**
>
>```c++
>/*线程堆栈的大小*/
>size_t stacksize;
>ret = pthread_attr_getstacksize(&attr,&stacksize);
>if(ret){
>    cout << "getstacksize Failed!" << endl;
>    exit(-1);
>}
>
>cout << "getstacksize:" << stacksize << endl;//8,388,608 = 0x800000 = 8M
>```
>
>这个是堆栈大小，是堆的还是栈的？
>
>**线程堆栈的地址**
>
>堆栈地址函数没用好。输出都是0。先这样吧后续有需求再补充。

#### 堆栈大小

从上面的例子也可以看出来，至少这个机器是`8M`的栈空间或者用命令`ulimit -s`查看（`ulimit -a`可以查看所有信息），至于堆嘛：

> [进程空间分配和堆栈大小](https://www.cnblogs.com/ladawn/p/8449399.html) 
>
> 堆的大小理论上大概等于进程虚拟空间大小-内核虚拟内存大小。windows下，进程的高位`2G`留给内核，低位`2G`留给用户，所以进程堆的大小小于`2G`。Linux下，进程的高位`1G`留给内核，低位`3G`留给用户，所以进程堆大小小于`3G`。

#### 线程阻塞

> [linux系统排查线程阻塞问题](<https://blog.csdn.net/qq_42609381/article/details/81412266>)
>
> ```shell
> [root@Joe ~]# pstack 11694 > one
> [root@Joe ~]# pstack 11694 > two
> [root@Joe ~]# diff one two
> ```
>
> ```shell
> [root@Joe ~]# strace -p 11694
> ```

#### `pstack`

> [pstack命令](<https://man.linuxde.net/pstack>) 
>
> 可显示每个进程的栈跟踪。`pstack` 命令必须由相应进程的属主或 `root` 运行。可以使用 `pstack` 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 `PID`。
>
> 
>
> [pstack使用和原理](https://www.cnblogs.com/mumuxinfei/p/4366708.html) 有个小总结
>
> 对`pstack`的作用, 大致可以归纳如下:
> 　1). 查看线程数(比`pstree`, 包含了详细的堆栈信息)
>     2). 能简单验证是否按照预定的调用顺序/调用栈执行
> 　3). 采用高频率多次采样使用时, 能发现程序当前的阻塞在哪里, 以及性能消耗点在哪里?
> 　4). 能反映出疑似的死锁现象(多个线程同时在wait lock, 具体需要进一步验证)

`pstack`不能使用问题

> `pstack`是一个脚本工具，其核心实现就是使用了`gdb`以及`thread apply all bt`命令；但是我的主机上`pstack`是一个执行文件
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue2/cmd$ which pstack
> /usr/bin/pstack
> (base) ejior@ejior-XPS-8930:~/huangyue2/cmd$ file /usr/bin/pstack
> /usr/bin/pstack: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.15, BuildID[sha1]=8ac2b4ee3bb6a1894c109c574221a45d6172c38d, stripped
> ```
>
> 拷贝了网上的脚本，运行之后也啥都没有

#### `strace`

> `strace`常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。`strace`可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。
>
> [分析进程调用pstack和starce](https://www.jianshu.com/p/d6686cb72f68)
>
> ```shell
> strace -f -F -o ~/straceout.txt myserver # 跟踪可执行程序
> # -f -F选项告诉strace同时跟踪fork和vfork出来的进程，-o选项把所有strace输出写到~/straceout.txt里 面，myserver是要启动和调试的程序。
> strace -o output.txt -T -tt -e trace=all -p 28979
> # 跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。
> ```
>
> 
>
> 

**掌握GDB、strace、perf等调试工具软件** 



### 多线程和多进程的区别

重点 面试官最最关心的一个问题，必须从CPU调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）

> 对于多核cpu，进程中的多线程并行执行。对于单核cpu，多线程在单cpu中并发执行，根据时间片切换线程。同一个线程同一时间段只能在一个cpu内核中运行，如果线程数小于cpu内核数，那么将有多余的内核空闲。

#### 共享&非共享

线程共享：

文件描述符表、每种信号的处理方式、当前工作目录、用户ID和组ID、内存地址空间（.text|.data|.bss|heap|）

线程非共享：

线程ID、处理器现场和栈指针（内核栈）、独立的栈空间（用户栈）、`errno`变量、信号屏蔽字、调度优先级。

**对照**

- `getpid() pthread_t pthread_self()`
- 

#### 进程切换

> [搞懂Select，Poll，Epoll的区别](<https://www.itqiankun.com/article/select-poll-epoll>)
>
> 从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：
>
> ```shell
> 1. 保存处理机上下文，包括程序计数器和其他寄存器。
> 2. 更新PCB信息。
> 3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
> 4. 选择另一个进程执行，并更新其PCB。
> 5. 更新内存管理的数据结构。
> 6. 恢复处理机上下文。
> ```
>
> 
>
> 
>
> 

## 僵尸进程

> [孤儿进程与僵尸进程总结](https://www.cnblogs.com/Anker/p/3271773.html)
>
> **如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免**
>
> 僵尸进程是要回收的，回收什么？回收PCB、这个PCB里记录了进程死亡的原因。写了两个例子`./competition/linux/dead&orphan/zombie_w_stat.c`和`./competition/linux/dead&orphan/zombie_wp_stat.c` 就是说明下能看到子进程退出状态。
>
> ```c++
> 
> ```
>
> **orphan进程**
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ sudo gcc orphan.c -o test.o
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ ./test.o 
> I am father process.
> I am the child process.
> pid: 14705      ppid:14704
> I will sleep five seconds.
> father process is  exited.
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ pid: 14705    ppid:1 
> # 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
> child process is exited.
> ```
>
> 此文给的一些例子，都可以在退出父进程后自动消灭僵尸进程。和此文给的杀死僵尸进程的方法类似。
>
> ```shell
> ./zombie1.o
> I am father process.I will sleep two seconds
> I am child process.I am exiting.
> PID  PPID S TT       COMMAND
> 14193 17004 T pts/19   top
> 14679 17004 S pts/19   ./t
> 14680 14679 Z pts/19   [t] <defunct> # 父进程内查看是看得到这个僵尸进程的
> 14683 14679 S pts/19   sh -c ps -o pid,ppid,state,tty,command
> 14684 14683 R pts/19   ps -o pid,ppid,state,tty,command
> 17004 17003 S pts/19   -bash
> father process is exiting. # 退出之后用top就看不到了
> ```
>
> 
>
> **僵尸进程解决办法**
>
> **（1）通过信号机制**
>
> 子进程退出时向父进程发送`SIGCHILD`信号，父进程处理`SIGCHILD`信号。在信号处理函数中调用wait进行处理僵尸进程。
>
> ```c++
> #include <stdio.h>
> #include <unistd.h>
> #include <errno.h>
> #include <stdlib.h>
> #include <signal.h>
> 
> static void sig_child(int signo);
> 
> int main()
> {
> pid_t pid;
> //创建捕捉子进程退出信号
> signal(SIGCHLD,sig_child);
> pid = fork();
> if (pid < 0)
> {
>   perror("fork error:");
>   exit(1);
> }
> else if (pid == 0)
> {
>   printf("I am child process,pid id %d.I am exiting.\n",getpid());
>   exit(0);
> }
> printf("I am father process.I will sleep two seconds\n");
> //等待子进程先退出
> sleep(2);
> //输出进程信息
> system("ps -o pid,ppid,state,tty,command");
> printf("father process is exiting.\n");
> return 0;
> }
> 
> static void sig_child(int signo)
> {
> pid_t        pid;
> int        stat;
> //处理僵尸进程
> while ((pid = waitpid(-1, &stat, WNOHANG)) >0)
>       printf("[Line %d] child:%d state:%d terminated.\n", __LINE__,pid,stat);
> }
> ```
>
> ```shell
> ./zombie_k_sig.o
> I am father process.I will sleep two seconds
> I am child process,pid id 16700.I am exiting.
> [Line 40] child:16700 state:0 terminated. # 这个state是子进程的死亡信息
> PID  PPID S TT       COMMAND
> 14193 17004 T pts/19   top
> 14733 17004 T pts/19   top
> 16699 17004 S pts/19   ./t
> 16701 16699 S pts/19   sh -c ps -o pid,ppid,state,tty,command
> 16702 16701 R pts/19   ps -o pid,ppid,state,tty,command
> 17004 17003 S pts/19   -bash
> father process is exiting.
> ```
>
> 相比之下确实少了一个`Z`进程
>
> **(2) fork两次**
>
> ```shell
> ./zombie_2fork.o
> [Line 40] child:17395 processing. # 可见父进程在这里阻塞了
> I am the first child process.pid:17395  ppid:17394
> PID  PPID S TT       COMMAND
> 15747 15746 S pts/19   -bash
> 17394 15747 S pts/19   ./t
> 17395 17394 S pts/19   ./t
> 17396 17395 S pts/19   ./t
> 17397 17395 S pts/19   sh -c ps -o pid,ppid,state,tty,command
> 17398 17397 R pts/19   ps -o pid,ppid,state,tty,command
> first procee is exited.
> [Line 47] child:17395 terminated.
> I am the second child process.pid: 17396      ppid:1
> ```
>
> 说实在这个没太看懂，不过确定了`waitpid`是阻塞进程的了。

`signal`

> [C 库函数 - signal()|菜鸟教程](<https://www.runoob.com/cprogramming/c-function-signal.html>)
>
> ```c++
> void (*signal(int sig, void (*func)(int)))(int) // 函数的声明
> ```
>
> 此文有例子，简单来说就是一个处理回调函数的接口，接受到`sig`信号然后处理`func`函数。

### `wait & waitpid`

```c++
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options); // pid = -1时，回收任意一个子进程
waitpid(-1,&status,0) == wait(&status) 
```

- `waitpid`多了一个`option`参数，可以选择不挂起，及非阻塞。

- 一个`wait & waitpid`的调用，只能回收一个进程。

### 查看僵尸进程

>  [linux杀死僵尸进程](https://www.cnblogs.com/mayhh/p/9968428.html)
>
>  `top`命令配合左上角的`zombie`就可以确定是否有僵尸进程了。
>
>  ```shell
>  # -A 参数列出所有进程 -o 自定义输出字段
>  (base) ejior@ejior-XPS-8930:~$ ps -A -ostat,ppid,pid,cmd,user |grep -e '^[Zz]' # grep -e<范本样式> 或 --regexp=<范本样式> : 指定字符串做为查找文件内容的样式。
>  Zs     389   392 [bundle] <defunct>          git
>  ZN   23717 27925 [debconf-communi] <defunct> ejior
>  
>  (base) ejior@ejior-XPS-8930:~$ ps aux | grep Zs |  grep -v grep
>  git       1606  0.0  0.0      0     0 ?        Zs   17:43   0:00 [bundle] <defunct>
>  ejior     3205  0.0  0.0  44188  4828 ?        Ss   5月09   8:20 dbus-daemon --fork --session --address=unix:abstract=/tmp/dbus-Z0PsNZsTnh
>  
>  $ kill -HUP <僵尸进程父ID> # 杀死僵尸进程
>  ```
>
>  

## 死锁

死锁是怎么产生的

死锁检测

> [linux死锁检测的一种思路](https://www.cnblogs.com/mumuxinfei/p/4365697.html) 有代码：`D:\00-personal\05-code\dead_lock_sample`
>
> 这个用拓扑排序解决死锁，很新颖嘛。

### 条件变量

不是锁，

1. CPU的执行方式

# 故障排查

代码中遇到进程阻塞，进程僵死，内存泄漏，程序崩溃等情况怎么排查。

> [线上linux系统故障排查之一：CPU使用率过高](<https://www.jianshu.com/p/6d573e42310a>)
>
> 有`top`命令的详细解释，后面用的是`jstack`。
>
> ```shell
> $ top -p 41843 -H # 查看进程的线程使用cpu情况
> ```
>
> 

## 协程


1. 有没有了解过协程？说下协程和线程的区别？







## 内存空间分布
   c++进程内存空间分布（注意各部分的内存地址谁高谁低，注意栈从高道低分配，堆从低到高分配）

```shell
# 利用size命令也可以看到程序的各段大小
$ size dead_lock_demo 
   text    data     bss     dec     hex filename
  17315     784     592   18691    4903 dead_lock_demo
```



   > [c++进程内存空间分布](<https://blog.csdn.net/xiaozuo2017/article/details/81452869>)
   >
   > 内存分布分为5个部分，从高地址到低地址依次为 栈区（stack），堆区（heap），未初始化数据段（uninitialized data），初始化数据段（initialize data），代码段（text）。
   >
   > ![](http://www.geeksforgeeks.org/wp-content/uploads/Memory-Layout.gif)
   >
   > ![hehe](https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153)
   >

### 堆栈多线程

堆是线程共有还是私有，堆是进程共有还是私有，栈呢

> 栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　`SS/ESP`寄存器。
>
> ```shell
> # 栈段寄存器SS
> # 栈顶指针ESP
> ```
>
> 



   ## PCB

> 为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为[进程控制块](https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97/7205297)（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。
>
> [PCB（进程控制块）讲解](<https://blog.csdn.net/IT_10/article/details/89819138>)
>
> PCB：进程控制块，实际是一个结构体，放在`sched.h`文件中，Linux下可以通过`whereis sched.h`命令查看具体路径：`/usr/src/linux-headers-4.15.0-101/include/linux/sched.h`
>
> - 进程id、进程的状态：初始、就绪、运行、挂起、终止
> - 进程切换时需要保存和恢复的CPU寄存器
> - 描述虚拟地址空间的信息
> - 描述控制终端的信息
> - 当前工作目录位置
> - `umask`掩码
> - 文件描述符表
> - 和信号相关信息

## MMU

> [MMU (一）](https://www.cnblogs.com/ikaka/p/3602536.html)
>
> 现代操作系统普遍采用虚拟内存管理（Virtual Memory Management）机制，这需要处理器中的`MMU`（Memory Management Unit，内存管理单元）提供支持。
>
> ![](https://images0.cnblogs.com/blog/561278/201403/152154483084338.png)

[bilibili:](<https://www.bilibili.com/video/BV1NZ4y1x7VS?p=77>)

> 文中观点，每个进程都是`1~4G`，其中用户空间由MMU映射成不同的物理内存地址，而内核的用的用一块地址。
>
> PCB是在内核中的。
>
> MMU会给内存分级。1、2、3，类似cache1、2、3？

## ELF

ELF是什么？其大小与程序中全局变量的是否初始化有什么关系（注意.bss段）

>  [ELF文件section大小的疑惑](<https://bbs.csdn.net/topics/390951902>)
>
> 我输出ELF文件所有的section大小，并把它们加到了一起获得的结果比我的文件大小还大，这是为什么？  
> 这不正常啊，ELF又不是只有section区，还有程序区啊，为什么这个大小会超出文件的大小呢？
>
> 我使用readelf -S 命令查看ELF文件的头section信息，大小和我程序显示的大小是一致的 。
>
> A：其中一个section区 .bss 存放程序未初始化的全局变量，在运行时初始化为0，其长度应为0 不计算在内

我自己写了个例子测试，看起来是有影响的

```shell
$ size temp # 无
   text    data     bss     dec     hex filename
   1192     556       4    1752     6d8 temp
-rwxr-xr-x 1 root  root    8680 7月  22 13:39 temp
$ size temp # int bss_var[10000];
   text    data     bss     dec     hex filename
   1192     556   40032   41780    a334 temp
-rwxr-xr-x 1 root  root    8680 7月  22 13:46 temp
$ size temp# int bss_var; ~ int bss_var5;
   text    data     bss     dec     hex filename
   1192     556      28    1776     6f0 temp
-rwxr-xr-x 1 root  root    8840 7月  22 13:47 temp
```

> 一个明确解答：[关于BSS段的大小](<https://blog.csdn.net/fivedoumi/article/details/53085440>)
>
> 先明确 BSS 段“存放”的是未初始化的全局变量与局部静态变量，此处指的存放是指为其预留空间（占位符）。但BSS段在磁盘上不是真的占用变量大小的空间，它仅是在该段中记录了所有未初始化全局变量与局部静态变量的大小总和，至于每个变量的大小则存储在符号表的size属性中。

> [ELF 格式详解（一）](<https://zhuanlan.zhihu.com/p/73114831>)
>
> **ELF 全称 “Executable and Linkable Format”，即可执行可链接文件格式，目前常见的Linux、 Android可执行文件、共享库（.so）、目标文件（ .o）以及Core 文件（吐核）均为此格式。**
>
> 

> [Linux ELF: ELF文件结构简单梳理](<https://www.jianshu.com/p/dd5aec5826da>)
>
> ![](https://upload-images.jianshu.io/upload_images/807220-5cdd5e1bd1b2c8ce?imageMogr2/auto-orient/strip|imageView2/2/w/906/format/webp)
>
> 这个文章说有四种，除了静/动态链接库和可执行文件，还有一个`core dump`文件。而
>
> [ELF文件格式解析](<https://blog.csdn.net/dddxxxx/article/details/80347610>)
>
> 说只有知道3种即可。另外这个文章还说“我们主要是以Shared Object File(.so)为重点分析对象，因为我们在**逆向**`APK`中会遇到的绝大部分都是此类文件”

### ELF视图

> ELF文件格式提供了两种视图，分别是链接视图和执行视图。链接视图是以节（section）为单位，执行视图是以段（segment）为单位。链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。
>
> 文件可以分为四个部分：
>
> - ELF header： 描述整个文件的组织。
> - Program Header Table: 描述文件中的各种segments，用来告诉系统如何创建进程映像的。
> - sections 或者 segments：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件，也就是说，在链接阶段，我们可以忽略program header table来处理此文件，在运行阶段可以忽略section header table来处理此程序（所以很多加固手段删除了section header table）。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。
> - Section Header Table: 包含了文件各个section的属性信息，我们都将结合例子来解释。
>
> ![示意图](https://img-blog.csdn.net/20160521110434854)
>
> **程序头部表**（Program Header Table），如果存在的话，告诉系统如何创建进程映像。
> **节区头部表**（Section Header Table）包含了描述文件节区的信息，比如大小、偏移等。

上面都是粘贴的，有些概念理解不深，下面文章用`readelf`命令看了看其他的文件，是windows环境下的，我这里用Linux环境模拟下:

```shell
(base) ejior@ejior-XPS-8930:~/huangyue2$ ll
总用量 12
-rw-rw-r--  1 ejior ejior   85 7月   2 16:18 test.cpp
(base) ejior@ejior-XPS-8930:~/huangyue2$ g++ test.cpp -c -o t.o
(base) ejior@ejior-XPS-8930:~/huangyue2$ g++ test.cpp -o t
(base) ejior@ejior-XPS-8930:~/huangyue2$ ar crsv libt.a t.o
a - t.o
(base) ejior@ejior-XPS-8930:~/huangyue2$ g++ test.cpp -fPIC -shared -Wl,-soname,libt.so -o libtet.so.0.1
(base) ejior@ejior-XPS-8930:~/huangyue2$ ll
总用量 40
-rw-rw-r--  1 ejior ejior 1646 7月   2 16:25 libt.a # 静态库 
-rwxrwxr-x  1 ejior ejior 8120 7月   2 16:27 libtet.so.0.1* # 动态库
-rwxrwxr-x  1 ejior ejior 8608 7月   2 16:23 t* # 可执行程序
-rw-rw-r--  1 ejior ejior   85 7月   2 16:18 test.cpp # 源文件
-rw-rw-r--  1 ejior ejior 1504 7月   2 16:23 t.o # 目标文件
```

**命令详解参考[GCC](#compile)**

`readelf`

```shell
(base) ejior@ejior-XPS-8930:~/huangyue2$ readelf --help
用法：readelf <选项> elf-文件
 显示关于 ELF 格式文件内容的信息
 Options are:
  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I
  -h --file-header       Display the ELF file header
  -l --program-headers   Display the program headers
     --segments          An alias for --program-headers
  -S --section-headers   Display the sections' header
     --sections          An alias for --section-headers
  -g --section-groups    Display the section groups
  -t --section-details   Display the section details
  -e --headers           Equivalent to: -h -l -S
  -s --syms              Display the symbol table
     --symbols           An alias for --syms
```



> **`readelf`命令，**一般用于查看ELF格式的文件信息，常见的文件如在Linux上的可执行文件，动态库(\*.so)或者静态库(\*.a) 等包含ELF格式的文件。

#### 可执行程序

```shell
(base) ejior@ejior-XPS-8930:~/huangyue2$ readelf -h t # 可执行程序
ELF 头：
  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  版本:                              1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              EXEC (可执行文件) # 标记
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：               0x400430
  程序头起点：          64 (bytes into file)
  Start of section headers:          6624 (bytes into file)
  标志：             0x0
  本头的大小：       64 (字节)
  程序头大小：       56 (字节)
  Number of program headers:         9
  节头大小：         64 (字节)
  节头数量：         31
  字符串表索引节头： 28
```

#### 目标文件.o

```shell
(base) ejior@ejior-XPS-8930:~/huangyue2$ readelf -h t.o
ELF 头：
  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  版本:                              1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              REL (可重定位文件)
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：               0x0
  程序头起点：          0 (bytes into file)
  Start of section headers:          672 (bytes into file)
  标志：             0x0
  本头的大小：       64 (字节)
  程序头大小：       0 (字节)
  Number of program headers:         0
  节头大小：         64 (字节)
  节头数量：         13
  字符串表索引节头： 10
```

#### 静态库.a

```shell
(base) ejior@ejior-XPS-8930:~/huangyue2$ readelf -h libt.a

文件：libt.a(t.o)
ELF 头：
  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  版本:                              1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              REL (可重定位文件)
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：               0x0
  程序头起点：          0 (bytes into file)
  Start of section headers:          672 (bytes into file)
  标志：             0x0
  本头的大小：       64 (字节)
  程序头大小：       0 (字节)
  Number of program headers:         0
  节头大小：         64 (字节)
  节头数量：         13
  字符串表索引节头： 10
```

#### 动态库

```shell
(base) ejior@ejior-XPS-8930:~/huangyue2$ readelf -h libtet.so.0.1 
ELF 头：
  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  版本:                              1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              DYN (共享目标文件)
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：               0x5a0
  程序头起点：          64 (bytes into file)
  Start of section headers:          6264 (bytes into file)
  标志：             0x0
  本头的大小：       64 (字节)
  程序头大小：       56 (字节)
  Number of program headers:         7
  节头大小：         64 (字节)
  节头数量：         29
  字符串表索引节头： 26
```

奇怪，这里`ELF64`对应位是`1`，参考中的图片`ELF32`也对应`1`

![](https://img-blog.csdn.net/20160521110756954)

> [ELF文件结构描述](https://www.cnblogs.com/linhaostudy/p/8855238.html)
>
> ELF文件头结构及相关常数被定义在“`/usr/include/elf.h`”，因为ELF文件在各种平台下都通用，ELF文件有32位版本和64位版本的ELF文件的文件头内容是一样的，只不过有些成员的大小不一样。它的文件图也有两种版本：分别叫**“`Elf32_Ehdr`”**和**“`Elf64_Ehdr`”**。






3. 使用过哪些进程间通讯机制，并详细说明（重点）
4. 说出你所知道的各类linux系统的各类同步机制（重点），什么是死锁？如何避免死锁（每个技术面试官必问）
5. 列举说明linux系统的各类异步机制
6. exit() _exit()的区别？
7. 如何实现守护进程？
8. linux的内存管理机制是什么？
9. linux的任务调度机制是什么？
10. 标准库函数和系统调用的区别？
11. [多线程有什么好处？](https://www.cnblogs.com/liuyangofficial/p/7072595.html)


## 信号 `man 7 signal`

信号：列出常见的信号，信号怎么处理？

`SIGKILL/SIGSTOP`:不能被忽略；不能阻塞；只能执行。

系统如何将一个信号通知到进程？

> 实际上，信号的接收不是由用户进程来完成的，而是由内核代理。当一个进程P2向另一个进程P1发送信号后，内核接受到信号，并将其放在P1的信号队列当中。当P1再次陷入内核态时，会检查信号队列，并根据相应的信号调取相应的信号处理函数。

> [video:125-130](<https://www.bilibili.com/video/BV1NZ4y1x7VS?p=125>)
>
> - 简单、信息量少；所有信号都是内核发送和处理的。 
>
> 按键`ctrl + c & ctrl + z & ctrl + \` （段错误）非法内存访问

信号四要素：编号、名称、事件、默认处理动作。

```c++
int kill(pid_t pid, int sig); // man 2 kill  -send signal to a process
```

- kill 的`pid` 可以传入0：传输命令给同以进程组的所有进程（`fork`之后子进程就是父进程的一组的，`ps ajx`可以查看）

## 信号量

[Linux_信号与信号量](https://blog.csdn.net/sty23122555/article/details/51470949)

在学习信号量之前，我们必须先知道——Linux提供两种信号量：
（1） 内核信号量，由内核控制路径使用
（2）用户态进程使用的信号量，这种信号量又分为POSIX信号量和SYSTEM V信号量。

POSIX信号量又分为有名信号量和无名信号量：
1）有名信号量，其值保存在文件中，所以它既可以用于线程，也可以用于相关进程间，甚至是不相关进程。
2）无名信号量，其值保存在内存中。无名信号量常用于多线程间的同步，同时也用于相关进程间的同步。也就是说，无名信号量必须是多个进程（线程）的共享变量，无名信号量要保护的变量也必须是多个进程（线程）的共享变量，这两个条件是缺一不可的。

![](https://img-blog.csdn.net/20160521204618092?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

POSIX 信号量与SYSTEM V信号量的比较：
1. 对POSIX来说，信号量是个非负整数。常用于线程间同步。而SYSTEM V信号量则是一个或多个信号量的集合，它对应的是一个信号量结构体，这个结构体是为SYSTEM V IPC服务的，信号量只不过是它的一部分。常用于进程间同步。
2. POSIX信号量的引用头文件是“<semaphore.h>”，而SYSTEM V信号量的引用头文件是“<sys/sem.h>”。
3. 从使用的角度，System V信号量是复杂的，而Posix信号量是简单。比如，POSIX信号量的创建和初始化或PV操作就很非常方便。

```c++
int sem_init(sem_t *sem, int pshared, unsigned int value); // initialize an unnamed semaphore
// The pshared argument indicates whether this semaphore is to be shared between the threads of a process, or between processes.
// If  pshared  has  the  value  0, then the semaphore is shared between the threads of a process
// If pshared is nonzero, then the semaphore is shared between processes, and should be located in a region of shared memory
// The value argument specifies the initial value for the semaphore
```

```c++
#include <pthread.h>
#include <semaphore.h>
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>

int number; // 被保护的全局变量
sem_t sem_id;

void* thread_one_fun(void *arg)
{
	sem_wait(&sem_id);
	printf("thread_one have the semaphore\n");
	number++;
	printf("number = %d\n",number);
	sem_post(&sem_id);
}

void* thread_two_fun(void *arg)
{
	sem_wait(&sem_id);
	printf("thread_two have the semaphore \n");
	number--;
	printf("number = %d\n",number);
	sem_post(&sem_id);
}

int main(int argc,char *argv[])
{
	number = 1;
	pthread_t id1, id2;

	sem_init(&sem_id, 0, 1); 

	pthread_create(&id1,NULL,thread_one_fun, NULL);
	pthread_create(&id2,NULL,thread_two_fun, NULL);
	pthread_join(id1,NULL);
	pthread_join(id2,NULL);

	printf("main end!\n");
	return 0;
}
```



`error1:Linux编译错误：对‘sem_wait’未定义的引用`

> 在编译器链接选项中加入`-pthread`即可 `sudo g++ -std=c++11 -pthread semaphore_uname.cpp -o exe`

`D:\00-personal\05-code\competition\IPC\sem`后面的例子没跑通，死锁了。

# Linux系统

[video：bilibili -101](<https://www.bilibili.com/video/BV1NZ4y1x7VS?p=101>)

> linux下共有7种文件类型，只有三种是占用系统空间的（- 文件、d 目录、l软链接）；
>
> 伪文件：字符设备、块设备、管道设备、套接字（不占用磁盘空间，只占用内存）

1. linux的各种命令 给你场景让你解决
2. Linux了解么，查看进程状态ps，查看cpu状态 top。查看占用端口的进程号netstat grep
3. Linux的cpu 100怎么排查，top jstack，日志，gui工具
4. 怎么查看CPU负载，怎么查看一个客户下有多少进程

## alarm

**每个进程都有且只有一个定时器。**

```c++
unsigned int alarm(unsigned int seconds); // 返回是上次定时剩余的时间
```

`time`命令：

real : 程序执行的时间 = sys: 系统时间 + user：用户时间 + 等待时间 ；程序优化的瓶颈在IO

Linux内核是怎么实现定时器的

> 

## 会话

![](https://img2018.cnblogs.com/blog/952033/202001/952033-20200103182042686-2100862807.png)

```shell
(base) ejior@ejior-XPS-8930:~$ ps -o pid,ppid,pgid,sid,tty,comm 
  PID  PPID  PGID   SID TT       COMMAND
 8054  8053  8054  8054 pts/20   bash # SID是会话ID, 4个id同时相同的就是创建者
28470  8054 28470  8054 pts/20   ps   # 其他人的会话ID都和这个相同
```

### daemon

通常运行在后端，一般不与用户交互，周期性等待某个事件或周期性执行某个动作。不受用户登录影响。

最关键的就是`setsid()`创建一个新的`session`

1. 创建父子进程，父进程结束，子进程创建`session`
2. 改变工作目录`chdir()`
3. 重设文件权限掩码`umask()`
4. 重定向文件描述符；因为不与用户交互因此需要关闭（重定向）

> [【Linux编程】守护进程(daemon)详解与创建](<https://blog.csdn.net/woxiaohahaa/article/details/53487602>)
>
> 包含了和视频类似的手动创建方法、杀死，已经利用库函数创建的方法；
>
> ```shell
> ps -ef | grep 'daemon' # 找到
> sudo kill -3 26454     # 发送QUIT信号
> ```
>
> 

### `ps`

```shell
(base) ejior@ejior-XPS-8930:~$ ps ajx
 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
 1824  1910  1910  1910 tty7      1910 Ssl+   127   0:00 /usr/lib/gdm3/gdm-x-session /usr/bin/gnome-session --autostart /usr/share/gdm/greeter/autostart
 1910  1912  1910  1910 tty7      1910 Sl+      0   2:57 /usr/lib/xorg/Xorg vt7 -displayfd 3 -auth /run/user/127/gdm/Xauthority -background none -noreset # tty 是文字终端
 8054 31032 31032  8054 pts/20   31032 R+    1000   0:00 ps ajx
29100 31052 31052 29100 pts/2    29100 T     1000   0:00 mysql -uroot -p # pts是虚拟终端，带图形的
# ? 问号：无终端
$ ps -Lf <pid> # 查看进程的进程号、线程号(LWP)  和线程ID不是一回事
```





## core

1. core dump有没有遇到过，gdb怎么调试
2. linux如何设置core文件生成

### [Linux Core Dump](https://www.cnblogs.com/hazir/p/linxu_core_dump.html) ★

> 当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做**Core Dump**（中文有的翻译成“核心转储”)。
>
> 当程序运行过程中**异常终止**或**崩溃**时会发生 core dump，但什么具体的情景程序会发生异常终止或崩溃，例如我们使用 `kill -9` 命令杀死一个进程会发生 core dump 吗？实验证明是不能的，那么什么情况会产生呢？
>
> Linux 中信号是一种异步事件处理的机制，每种信号对应有其默认的操作，你可以在 **这里** 查看 Linux 系统提供的信号以及默认处理。默认操作主要包括
>
> - 忽略该信号（Ingore）、
> - 暂停进程（Stop）、
> - 终止进程（Terminate）、
> - 终止并发生core dump（core）等
>
> 以下列出几种信号，它们在发生时会产生 core dump:
>
> | Signal  | Action | Comment                                                      |
> | ------- | ------ | ------------------------------------------------------------ |
> | SIGQUIT | Core   | Quit from keyboard                                           |
> | SIGILL  | Core   | Illegal Instruction                                          |
> | SIGABRT | Core   | Abort signal from [abort](http://man7.org/linux/man-pages/man3/abort.3.html) |
> | SIGSEGV | Core   | Invalid memory reference                                     |
> | SIGTRAP | Core   | Trace/breakpoint trap                                        |
>
> 当然不仅限于上面的几种信号。这就是为什么我们使用 `Ctrl+z` 来挂起一个进程或者 `Ctrl+C` 结束一个进程均不会产生 core dump，因为前者会向进程发出 **SIGTSTP** 信号，该信号的默认操作为暂停进程（Stop Process）；后者会向进程发出**SIGINT** 信号，该信号默认操作为终止进程（Terminate Process）。同样上面提到的 `kill -9` 命令会发出 **SIGKILL** 命令，该命令默认为终止进程。而如果我们使用 `Ctrl+\` 来终止一个进程，会向进程发出 **SIGQUIT** 信号，默认是会产生 core dump 的。还有其它情景会产生 core dump， 如：程序调用 `abort()` 函数、访存错误、非法指令等等。

[Linux生成core文件、core文件路径设置](<https://blog.csdn.net/u011417820/article/details/71435031>)

### 设置core文件大小

```shell
ulimit -a # 列出所有资源的限制
ulimit -c # core 文件； 0: 程序错误不产生；1024:文件大于1024K不产生
ulimit -c fileSize # 设置core文件大小。 尽量将这个文件大小设置得大一些，程序崩溃时生成Core文件大小即为程序运行时占用的内存大小。可能发生堆栈溢出的时候，占用更大的内存
```

> 用上面命令只会对当前的终端环境有效，如果想需要永久生效，可以修改文件 `/etc/security/limits.conf`文件，关于此文件的设置参看 **这里** 。增加一行:

### 设置core文件的名称和文件路径

- 默认生成路径：输入可执行文件运行命令的同一路径下
- 默认生成名字：默认命名为core。新的core文件会覆盖旧的core文件

#### 设置`pid`作为文件扩展名

```shell
echo "1" > /proc/sys/kernel/core_uses_pid  # 修改 /proc/sys/kernel/core_uses_pid 文件内容为: 1
# or
sysctl -w kernel.core_uses_pid=1 kernel.core_uses_pid = 1
```

1：添加`pid`作为扩展名，生成的`core`文件名称为`core.pid`
0：不添加`pid`作为扩展名，生成的`core`文件名称为`core`

#### 控制core文件保存位置和文件名格式

```shell
echo "/corefile/core-%e-%p-%t" > /proc/sys/kernel/core_pattern
# or 
sysctl -w kernel.core_pattern=/corefile/core.%e.%p.%s.%E
```

就是修改这两个文件的内容，注意`echo`命令会将文件全部内容替换成`""`里的内容。

> `error200703 -bash: /proc/sys/kernel/core_uses_pid:` 权限不够
>
> [Why is editing core_pattern restricted?](https://unix.stackexchange.com/questions/343275/why-is-editing-core-pattern-restricted)
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue2/cmd$ sudo bash -c 'echo "1" > /proc/sys/kernel/core_uses_pid' # 记得单引号
> [sudo] ejior 的密码： 
> (base) ejior@ejior-XPS-8930:~/huangyue2/cmd$ cat /proc/sys/kernel/core_uses_pid
> 1
> ```

### 测试是否能生成core文件

```shell
kill -s SIGSEGV $$ # 运行后链接就断了
```

> [linux之kill命令详解](https://www.cnblogs.com/lhdz_bj/p/12963873.html)
>
> **`11) SIGSEGV`**:试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.这是**默认会导致进程流产的信号**

### 调试core

```shell
gdb ./test core-test-31639-1593754742
Core was generated by `./test'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004004e6 in main ()
(gdb) n
The program is not being run.
(gdb) run
Starting program: /home/ejior/huangyue2/cmd/test
```

#### 多线程死锁

> [多线程死锁及coredump](<https://blog.csdn.net/mm8591/article/details/42836269>)
>
> 一个正在生产环境下运行的进程死锁了，或者你只是在跑一个程序，并没有在调试器里面打开它，然后发现没有响应，日志输出也停止了。由于你是一个有经验的程序员，会想到“我刚刚加上了新的锁策略，不一定稳定，这可能是死锁了“。但是你不想就这么杀掉进程，因为多线程的 bug 不容易重现，遇上一次死锁可能要凭运气，错过了这次，它下次死锁可能会出现在你演示给老板看的时候……可以借助Core Dump来调试
>
> ```shell
> # 编译代码
> 	$> g++ -Wall -std=c++11 dead_lock_demo.cpp -o dead_lock_demo -g -pthread
> # 运行程序，发现程序打印出“about to dead_lock” 就不动了，现在我们使用gdb来调试。注意gdb的版本要高于7.0，之前使用过gdb6.3调试多线程是不行的。
> 
> # 产生core dump文件：
> 　　$> ps -aux | grep dead_lock_demo
> # 找出 dead_lock_demo 线程号，然后：
> 　　$> kill -11 pid
> # 然后调试：
> 　　$> gdb dead_lock_demo core
> 　　$> thread apply all bt
> ```
>
> [文件](D:\00-personal\05-code\competition\dead_lock_sample\dead_lock_core_dump.cpp) & [输出 ](D:\00-personal\05-code\competition\dead_lock_sample\dead_lock_core_dump.txt) 基本上打印出所有的线程堆栈之后就可以分析了。

#### `backtrace`

> [在Linux中如何利用backtrace信息解决问题](<https://blog.csdn.net/jxgz_leo/article/details/53458366>)
>
> 通常在这种情况下是通过拿到出问题时产生的core文件然后再利用`gdb`调试来看到出错时的程序栈信息，这是再好不过的了，**但当某些特殊的情况如不正确的系统设置或文件系统出现问题时导致我们没有拿到core文件**那我们还有补救的办法吗？本文将介绍在程序中安排当出现崩溃退出时把当前调用栈通过终端打印出来并定位问题的方法。
>
> ```c++
> #include <execinfo.h>
>  
> /* Store up to SIZE return address of the current program state in
>    ARRAY and return the exact number of values stored.  */
> int backtrace(void **array, int size);
>  
> /* Return names of functions from the backtrace list in ARRAY in a newly
>    malloc()ed memory block.  */
> char **backtrace_symbols(void *const *array, int size);
>  
> /* This function is similar to backtrace_symbols() but it writes the result
>    immediately to a file.  */
> void backtrace_symbols_fd(void *const *array, int size, int fd);
> ```
>
> **静态链接情况下的错误信息分析定位**
>
> ```shell
> sudo gcc -g -rdynamic backtrace.c add.c dump.c -o backtrace 
> # backtrace_symbols的实现需要符号名称的支持，在gcc编译过程中需要加入-rdynamic参数；
> (base) ejior@ejior-XPS-8930:~/huangyue2/cmd$ ./backtrace 
> 
> =========>>>catch signal 11 <<<=========
> Dump stack start...
> backtrace() returned 8 addresses
>   [00] ./backtrace(dump+0x2e) [0x400ba8]
>   [01] ./backtrace(signal_handler+0x2e) [0x400caa]
>   [02] /lib/x86_64-linux-gnu/libc.so.6(+0x354c0) [0x7fea416684c0]
>   [03] ./backtrace(add1+0x1a) [0x400b3d] # 3. 进而看到add1 因此可以断定错误出现再这地方0x400b3d
>   [04] ./backtrace(add+0x1c) [0x400b72]  # 2. 又看到add
>   [05] ./backtrace(main+0x2f) [0x400b05] # 1. 可以看到mian
>   [06] /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0) [0x7fea41653840]
>   [07] ./backtrace(_start+0x29) [0x400a09]
> Dump stack end...
> 段错误 (核心已转储)
> 
> (base) ejior@ejior-XPS-8930:~/huangyue2/cmd$ addr2line -e backtrace 0x400b3d 
> /home/ejior/huangyue/linuxcode/add.c:13  # 4. 跟踪下来是这一行
> ```
>
> 牛逼！后面还有动态链接库内部出错的解决方法，因为动态链接库是动态加载的，`backtrace`的地址不是`.so`真正的地址，因此需要计算偏移。具体方法是利用`linux`的进程map，找到段的位置，计算`backtrace`打印的位置与段位置的偏移；然后`addr2line -e libadd.so <偏移>`
>
> 他说还可以**用使用gcc的nm、readelif等命令直接对libadd.so分析**，但是没详细介绍，说的是用gcc生成map文件
>
> ```shell
> gcc -g -rdynamic add.c -fPIC -shared -o libadd.so -Wl,-Map,add.map # 生成map文件
> ```
>
> 总而言之，方法很多，有的是方法找到具体是哪一行出错了。
>
> **把gdb的结果拿出来对比一下呢**`gdb`调试一下之后：
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue2/cmd$ gdb ./backtrace core-backtrace-4898-1596524732
> Core was generated by `./backtrace'. # 调试之后自动运行到段错误的地方
> Program terminated with signal SIGSEGV, Segmentation fault.
> #0  0x0000000000400b3d in add1 (num=0) at add.c:13
> 13              *pTemp = 0x01;  /* 这将导致一个段错误，致使程序崩溃退出 */
> (gdb) r # 再run一下
> Starting program: /home/ejior/huangyue2/cmd/backtrace 
> 
> Program received signal SIGSEGV, Segmentation fault.
> 0x0000000000400b3d in add1 (num=0) at add.c:13
> 13              *pTemp = 0x01;  /* 这将导致一个段错误，致使程序崩溃退出 */
> (gdb) thread apply all bt # 打印所有线程堆栈 或者直接bt也行
> 
> Thread 1 (process 5846):
> #0  0x0000000000400b3d in add1 (num=0) at add.c:13
> #1  0x0000000000400b72 in add (num=0) at add.c:24
> #2  0x0000000000400b05 in main (argc=1, argv=0x7fffffffded8) at backtrace.c:20
> ```

##### 多线程情况

```shell
=========>>>catch signal 11 <<<=========
Dump stack start...
backtrace() returned 8 addresses
  [00] ./backtrace(dump+0x2e) [0x400dfc] 
  [01] ./backtrace(signal_handler+0x2e) [0x400efe]
  [02] /lib/x86_64-linux-gnu/libc.so.6(+0x354c0) [0x7ff5a84b64c0]
  [03] ./backtrace(add1+0x1a) [0x400d91] # 依然可以正常打印，但是看不出哪个线程
  [04] ./backtrace(add+0x1c) [0x400dc6]
  [05] ./backtrace(PrintHello+0x58) [0x400c9e]
  [06] /lib/x86_64-linux-gnu/libpthread.so.0(+0x76ba) [0x7ff5a88526ba]
  [07] /lib/x86_64-linux-gnu/libc.so.6(clone+0x6d) [0x7ff5a85884dd]
Dump stack end...
段错误 (核心已转储) # gdb也没能看出所有线程，可能因为没有加-g选项吧。不过gdb还是一下就定位到错误行了
```

#### `addr2line`

> `addr2line`工具是一个可以将指令的地址和可执行映像转换为文件名、函数名和源代码行数的工具。这在内核执行过程中出现崩溃时，可用于快速定位出出错的位置，进而找出代码的bug。



1. linux如何设置开机自启动
2. linux用过哪些命令、工具

## 程序性能检测工具

1. 用过哪些工具检测程序性能，如何定位性能瓶颈的地方

### `Perf`

[Perf – Linux下的系统性能调优工具，第 1 部分](https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/)

> Perf 是用来进行软件性能分析的工具。
>
> 通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。它不但可以分析指定应用程序的性能问题 (per thread)，也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。
>
> 安装[使用参考二](<https://blog.csdn.net/FZeroTHero/article/details/102909990>)
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ perf
> 程序“perf”尚未安装。 您可以使用以下命令安装：
> sudo apt install linux-tools-common
> sudo apt install linux-tools-4.15.0-99-generic
> ```
>
> **Perf list，perf 事件**
>
> 使用 `perf list` 命令可以列出所有能够触发 `perf` 采样点的事件，可以将它们划分为三类：
>
> - Hardware Event 是由 `PMU` 硬件产生的事件，比如 cache 命中，当您需要了解程序对硬件特性的使用情况时，便需要对这些事件进行采样；
>
> - Software Event 是内核软件产生的事件，比如进程切换，tick 数等 ;
>
> - Tracepoint event 是内核中的静态 tracepoint 所触发的事件，这些 tracepoint 用来判断程序运行期间内核的行为细节，比如 slab 分配器的分配次数等。
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ sudo gcc -o t1 -g test.c
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ sudo perf stat ./t1
> 
>  Performance counter stats for './t1':
> 
>         170.253031      task-clock (msec)         #    0.833 CPUs utilized          
>                  1      context-switches          #    0.006 K/sec                  
>                  0      cpu-migrations            #    0.000 K/sec                  
>                 42      page-faults               #    0.247 K/sec                  
>        737,784,977      cycles                    #    4.333 GHz                    
>        550,715,493      instructions              #    0.75  insn per cycle         
>        110,133,503      branches                  #  646.881 M/sec                  
>              6,183      branch-misses             #    0.01% of all branches        
> 
>        0.204348976 seconds time elapsed
> ```
>
> 程序 `t1` 是一个 CPU bound 型，因为`task-clock (msec)` 接近 1。对 `t1` 进行调优应该要找到热点 ( 即最耗时的代码片段 )，再看看是否能够提高热点代码的效率。
>
> 缺省情况下，除了 `task-clock (msec)` 之外，`perf stat` 还给出了其他几个最常用的统计信息：
>
> - `task-clock (msec)`：CPU 利用率，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO
>
> - `Context-switches`：进程切换次数，记录了程序运行过程中发生了多少次进程切换，频繁的进程切换是应该避免的。
>
> - `CPU-migrations`：表示进程 `t1 `运行过程中发生了多少次 CPU 迁移，即被调度器从一个 CPU 转移到另外一个 CPU 上运行
>
> - `Cycles`：处理器时钟，一条机器指令可能需要多个 cycles
>
> - `Instructions`: 机器指令数目；`IPC insn per cycle`：是 Instructions/Cycles 的比值，该值越大越好，说明程序充分利用了处理器的特性
>
> -  `branch-misses` [记一次perf branch-misses 100%的调试经历](https://www.cnblogs.com/haoxing990/p/12811260.html)
>
> 还有一些我这里没有，就没列举，以下跑了下之前测试虚函数指针的程序，改程序有较多的`printf`。
>
> ```shell
>  Performance counter stats for './test.o':
>           0.766077      task-clock (msec)         #    0.015 CPUs utilized          
>                  1      context-switches          #    0.001 M/sec                  
>                  0      cpu-migrations            #    0.000 K/sec                  
>                109      page-faults               #    0.142 M/sec                  
>          3,276,602      cycles                    #    4.277 GHz                    
>          3,339,796      instructions              #    1.02  insn per cycle         
>            589,429      branches                  #  769.412 M/sec                  
>             17,233      branch-misses             #    2.92% of all branches        
>        0.052286059 seconds time elapsed
> ```
>
> 从`CPUs utilized`可以看出，这应该是一个`IO`型的程序。
>
> **perf top**出来的信息，和参考差距有点大。
>
> **使用 `perf record`, 解读 report ** 比如说您已经断定目标程序计算量较大，也许是因为有些代码写的不够精简。那么面对长长的代码文件，究竟哪几行代码需要进一步修改呢？这便需要使用 `perf record` 记录单个函数级别的统计信息，并使用` perf report `来显示统计结果。
>
> `error 1`:
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ sudo perf record – e cpu-clock ./t1
> Workload failed: No such file or directory
> # 这个错误没解决，我尝试将可执行文件从挂载区弄到非挂载区，可以生成perf.data文件但是依然报错，并且不能打开
> ```
>
> [可能解决方案：BCOS区块链性能分析工具的安装和使用perf+火焰图](<https://blog.csdn.net/weixin_43946212/article/details/100161808>)
>
> 

[Perf – Linux下的系统性能调优工具，第 2 部分](https://www.ibm.com/developerworks/cn/linux/l-cn-perf2/)

> `perf top，perf stat, perf record` 等也是内核调优的基本手段
>
> 

[系统级性能分析工具perf的介绍与使用](https://www.cnblogs.com/arnoldlu/p/6241297.html)



[系统级性能分析工具 — Perf](https://blog.csdn.net/zhangskd/article/details/37902159)

[perf Examples](<http://www.brendangregg.com/perf.html>)



1. `netstat tcpdump ipcs ipcrm` （如果这四个命令没听说过或者不能熟练使用，基本上可以回家，通过的概率较小 ^_^ ，这四个命令的熟练掌握程度基本上能体现面试者实际开发和调试程序的经验)


## `netstat`

> [Linux netstat命令详解](https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html)
>
> `netstat `命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (`multicast` Memberships) 等等。
>
> 从整体上看，netstat的输出结果可以分为两个部分：
>
> - 一个是Active Internet connections，称为有源TCP连接，其中"Recv-Q"和"Send-Q"指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。
>
> - 另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。
>
> **列出所有端口 `netstat -a | more`**
>
> **列出所有 tcp 端口 `netstat -at`**
>
> **列出所有 udp 端口 `netstat -au`**
>
> **列出所有处于监听状态的 Sockets** ：**只显示监听端口**`netstat -l | more`；只列出所有监听 tcp 端口 `netstat -lt`；**只列出所有监听 udp 端口 netstat -lu**；**只列出所有监听 UNIX 端口 netstat -lx**
>
> **显示所有端口的统计信息 netstat -s**；**显示 TCP 或 UDP 端口的统计信息 netstat -st 或 -su**
>
> 。。。

## `tcpdump `

> [tcpdump网络调试](https://www.cnblogs.com/roverliang/p/11435219.html)
>
> 用简单的话来定义`tcpdump`，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。` tcpdump`可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。
>
> ```shell
> $ sudo tcpdump # 默认启动
> ```
>
> 普通情况下，直接启动`tcpdump`将监视第一个网络接口上所有流过的数据包。
>
> ```shell
> $ tcpdump host 210.27.48.1 # 可以指定ip,例如截获所有210.27.48.1 的主机收到的和发出的所有的数据包
> ```
>
> 

## `ifconfig`

> [Linux网卡命名enp3s0说明](https://segmentfault.com/a/1190000006078381)
>
> ```shell
> en - Ethernet
> sl - serial line IP
> wl - wlan
> ww - wwan
> ```

## ` ipcs ipcrm`

> [Linux ipcs命令与ipcrm命令的用法详解](<https://www.jb51.net/article/40805.htm>)
>
> `linux/uinx`上提供关于一些进程间通信方式的信息，包括共享内存，消息队列，信号
>
> ```shell
> $ ipcs -a  # 是默认的输出信息 打印出当前系统中所有的进程间通信方式的信息
> $ ipcs -m  # 打印出使用共享内存进行进程间通信的信息
> $ ipcs -q  # 打印出使用消息队列进行进程间通信的信息
> $ ipcs -s  # 打印出使用信号进行进程间通信的信息
> ```
>
> `ipcrm`移除一个消息对象。或者共享内存段，或者一个信号集，同时会将与ipc对象相关链的数据也一起移除。当然，只有超级管理员，或者ipc对象的创建者才有这项权利啦。
>
> ```shell
> $ ipcrm -M shmkey  # 移除用shmkey创建的共享内存段
> $ ipcrm -m shmid   # 移除用shmid标识的共享内存段
> $ ipcrm -Q msgkey  # 移除用msqkey创建的消息队列
> $ ipcrm -q msqid   # 移除用msqid标识的消息队列
> $ ipcrm -S semkey  # 移除用semkey创建的信号
> $ ipcrm -s semid   # 移除用semid标识的信号
> ```
>
> 





1. `cpu` 内存 硬盘 等等与系统性能调试相关的命令必须熟练掌握，设置修改权限 tcp网络状态查看 各进程状态 抓包相关等相关命令 必须熟练掌握



1. awk sed需掌握

## `awk sed`

> [linux awk命令详解](https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html)
>
> `awk`是一个强大的文本分析工具，相对于`grep`的查找，`sed`的编辑，`awk`在其对数据分析并生成报告时，显得尤为强大。
>
> 行拆分
>
> [Linux sed 命令](<https://www.runoob.com/linux/linux-comm-sed.html>)
>
> Linux sed 命令是利用脚本来处理文本文件。
>
> 列拆分

1. `gdb`调试相关的经验，会被问到

[面试问我，创建多少个线程合适？我该怎么说](<https://www.jianshu.com/p/f30ee2346f9f>)

## `Select，Poll，Epoll`

epoll和select有什么区别。
同上。epoll_creat，_ctl和_wait干了啥讲了一遍。面试官问了一下select能管多少个fd，epoll能管多少个。

首先要搞懂，什么是IO模型

>[聊聊Linux 五种IO模型](<https://www.jianshu.com/p/486b0965c296>)
>
>

> [搞懂Select，Poll，Epoll的区别](<https://www.itqiankun.com/article/select-poll-epoll>)
>
> select、poll 和 epoll 都是 Linux API 提供的 IO 复用方式。
>
> 

# 常用命令

## `grep`

```shell
$ grep -r 'main' ./ -n ## 直接找文件内容 -r递归 -n给出行号
./pthread_test.cpp:50:int main ()
./pthread_test.cpp:57:          cout << "main() : Create thread, " << i;
./sched_test.cpp:50:int main(int argc,char *argv[ ])
匹配到二进制文件 ./t
匹配到二进制文件 ./t1
匹配到二进制文件 ./test.o
```

## `xargs`

```shell
find ./ -maxdepth 1 -type f | xargs ls -l # 处理find的管道结果
find ./ -maxdepth 1 -type f -exec ls -l {} \; # 功能和上面一样，这个效率差点
```

## `vim`



## `ldd`

`ldd命令用于打印程序或者库文件所依赖的共享库列表。`

## `echo`

```shell
$ echo $PATH # 查看环境变量
(base) ejior@ejior-XPS-8930:~/huangyue/linuxcode/make_file$ echo $SHELL
/bin/bash
(base) ejior@ejior-XPS-8930:~/huangyue/linuxcode/make_file$ echo $TERM
vt100
(base) ejior@ejior-XPS-8930:~/huangyue/linuxcode/make_file$ echo $LANG
zh_CN.UTF-8
(base) ejior@ejior-XPS-8930:~/huangyue/linuxcode/make_file$ echo $HOME
/home/ejior
$ env # 列出所有环境变量
```

# 其他

## 用户态和内核态

[Linux下如何从用户态切换到内核态？](<https://blog.csdn.net/shanghx_123/article/details/83151064>)

> 当一个程序运行时，如果它是在用户空间下执行，我们把此时运行得程序的这种状态成为用户态，而当这段程序执行在内核的空间执行时，这种状态称为内核态。
>
> 如何切换？
>
> 答案是软件中断。软件中断和我们常说的中断（硬件中断）不同之处在于，它是通过软件指令触发而并非外设引发的中断，也就是说，又是编程人员开发出的一种异常（该异常为正常的异常）。Linux操作系统一般是通过软件中断从用户态切换到内核态。

## 内存申请失败

如何判断？[判断用new申请内存是否成功](<https://blog.csdn.net/lien0906/article/details/36869051>)

标准C++用抛出异常来处理new内存分配失败的问题，所以可以这样写：

```c++
try
{
	int *p_i=new int[1024*1024*1024];
}
catch(bad_alloc &memExp)
{
	// 失败以后，要么 abort 要么重分配
	cerr<<memExp.what()<<endl;
}
```



如何切换？

调用系统调用函数。



# Compile

## `g++ `常用

> [GCC编译基础](<https://zhuanlan.zhihu.com/p/151219726?utm_source=wechat_session&utm_medium=social&utm_oi=65958932643840>)
>
> 一个完整的C++编译过程（例如`g++ a.cpp`生成可执行文件），总共包含以下四个过程：
>
> - 编译预处理，也称预编译，可以使用命令`g++ -E`执行；
> - 编译，可以使用`g++ -S`执行 | 检测语法规范、编译成汇编指令
> - 汇编，可以使用`as` 或者`g++ -c`执行 | 汇编翻译机器码
> - 链接，可以使用`g++ xxx.o xxx.so xxx.a`执行 | **数据段合并&地址回调**
>
> ```shell
> $ gcc -I./inc hello.c -o hello # -I 指定include目录
> $ -g # gdb 调试
> ```
>
> `-lpthread` : `-llibrary` 制定编译的时候使用的库。例子用法
>
> ```shell
> gcc -lcurses hello.c # 使用ncurses库编译程序
> ```
>
> [什么是数据段合并呢？](<https://www.bilibili.com/video/BV1CV411k7En?p=35>)
>
> 

解释上述`ELF`中的程序：

```sh
(base) ejior@ejior-XPS-8930:~/huangyue2$ ll
-rw-rw-r--  1 ejior ejior   85 7月   2 16:18 test.cpp
(base) ejior@ejior-XPS-8930:~/huangyue2$ g++ test.cpp -c -o t.o # 
(base) ejior@ejior-XPS-8930:~/huangyue2$ g++ test.cpp -o t
(base) ejior@ejior-XPS-8930:~/huangyue2$ ar crsv libt.a t.o # KEY1
a - t.o

(base) ejior@ejior-XPS-8930:~/huangyue2$ g++ test.cpp -fPIC -shared -Wl,-soname,libt.so -o libtet.so.0.1 # KEY2
(base) ejior@ejior-XPS-8930:~/huangyue2$ ll
-rw-rw-r--  1 ejior ejior 1646 7月   2 16:25 libt.a
-rwxrwxr-x  1 ejior ejior 8120 7月   2 16:27 libtet.so.0.1*
-rwxrwxr-x  1 ejior ejior 8608 7月   2 16:23 t*
-rw-rw-r--  1 ejior ejior   85 7月   2 16:18 test.cpp
-rw-rw-r--  1 ejior ejior 1504 7月   2 16:23 t.o

(base) $ gcc -c add.c -o add.o -fPIC
(base) $ gcc -shared libname.so add.o sub.o div.o # 将库链接成动态库
(base) $ gcc -l -L # -l 指定库名 -L指定库的路径
```

- `KEY1:` 使用`ar`命令进行“归档”（.a的实质是将文件进行打包）

  - `r` 替换归档文件中已有的文件或加入新文件 (必要)

  - `c` 不在必须创建库的时候给出警告

  - `s` 创建归档索引

  - `v` 输出详细信息

  - `collect2: error: ld returned 1 exit status`这个`ld`调用`collect2`链接器。这个问题基本上就是没链接对，添加方法只要`gcc hello.c libmymath.a -o t` 

    **注意可以不用声明哦**，但是`-Wall`能看出来，会给我完成隐式声明implicit declaration；但隐式声明返回值默认是`int`，如果隐式声明的函数返回值不是`int`就会报错了。

    

- `KEY2:` 使用`g++ -shared` 命令指定编译生成的是一个动态库

  - `shared`:告诉编译器生成一个动态链接库
  - `-Wl,-soname`:指示生成的动态链接库的别名（这里是`libtest.so`）
  - `-o`:指示实际生成的动态链接库（这里是`libtest.so.0.1`）
  - `-fPIC`
  - - `fPIC`的全称是 `Position Independent Code`， 用于生成位置无关代码（看不懂没关系，总之加上这个参数，别的代码在引用这个库的时候才更方便，反之，稍不注意就会有各种乱七八糟的报错）。
    - 使用`-fPIC`选项生成的动态库，是位置无关的。这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行。通常的方法是获取指令指针的值，加上一个偏移得到全局变量/函数的地址。
    - 关于`PIC`参数的详细解读：[点此链接](https://link.zhihu.com/?target=http%3A//blog.sina.com.cn/s/blog_54f82cc201011op1.html)
  - 直接运行会错：
    - 连接器：需要`-l` 和`-L`
    - 动态连接器：需要提供动态库所在目录的位置；是个环境变量：`export LD_LIBRARY_PATH = 'path'`这样的就可以用了。`export`导出然后重新赋值。
    - 但是，环境变量是进程的概念；关闭终端就没了。可以修改`~/.bashrc`来永久修改，但是呢这是个脚本，修改完要运行：`. .bashrc` & `source .bashrc` ；还有一种解决方法写入配置文件`sudo vi /etc/ld.so.conf`然后`sudo ldconfig -v`更新之。




## `gdb`

```shell
$ gcc main.c -o -g
$ gdb a.out # list 1 到第一行  或者 l 翻页 # b 52 断点 # r 运行 # n next 越过 s step 进入函数。
# p variable 查看变量 # continue 继续运行。# finish 结束函数 # start 从头开始调试 
# info b 查看断点信息 # b if i = 3 只在i=3时断点生效
# display <variable> 跟踪变量 undisplay <id>取消跟踪
```

- `gdb`追段错误很简单，直接`run`，程序停止的地方就是段错的地方。

```shell
(gdb) set args <aa bb cc dd> # 设置main的参数
(gdb) run <aa bb cc dd>      # 也可以
```

- 栈帧 - 以函数为单位？

```shell
(gdb) bt # 列出栈帧
(gdb) frame <num> # 切换栈帧
```

### 多进程

```shell
(gdb) set follow-fork-mode child
(gdb) set follow-fork-mode parten # default
```







### 多线程

gdb怎么查看某个线程



## `makefile`

项目管理，节省点时间。

```makefile
目标:依赖 # ALL: 可指定终极目标
	规则(命令)

src = $(wildcard ./*.c) # $是函数， wildcard 函数名； ./*.c 参数；脚本中函数的参数只有一种类型：string
obj = $(patsubst %.c, %.o, $(src)) # 三个参数，将$(src)中的，包含%.c的替换成%.o
# for example:
#	src = add.c sub.c div.c ===$(patsubst)===> obj = add.o sub.o div.o

clean:
	-rm -rf # 命令前加一个 - ？这个小-是有用的，表示出错依然执行，删除不存在文件不报错。牛逼牛逼！
make clean # -n 可以让你模拟一下运行情况

$@ 在规则的命令中表示目标
$^ 在规则的命令中表示所有依赖条件
$< 在规组的命令中表示第一个依赖条件

# 模式规则
%.o:%.c
	gcc -c $< -o $@ # 一个规则搞定

$(obj):%.o:%.c # 静态模式规则 多个模式规则时，防止歧义
	gcc -c $< -o $@
	
.PHONY:clean ALL # 伪目标 防止有一个文件叫clean
```



## `g++和gcc`

> [g++和gcc的相同点和区别](<https://blog.csdn.net/hitwengqi/article/details/8013754>) 有参数详解
>
> 



## `valgrind`

> [Valgrind使用简介](<https://blog.csdn.net/destina/article/details/6198443>)
>
> 有比较多的例子，这里只跑了第一种。
>
> ```c++
> #include <stdlib.h>
> 
> void f(void)
> {
> 	int* x = malloc(10 * sizeof(int));
> 	x[10] = 0;  //问题1: 数组下标越界
> }               //问题2: 内存没有释放
> 
> int main(void)
> {
> 	f();
> 	return 0;
> }
> ```
>
> ```shell
> ==11714== Memcheck, a memory error detector
> ==11714== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
> ==11714== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
> ==11714== Command: ./exe
> ==11714== 
> ==11714== Invalid write of size 4
> ==11714==    at 0x400544: f (in /home/ejior/huangyue/linuxcode/exe)
> ==11714==    by 0x400555: main (in /home/ejior/huangyue/linuxcode/exe)
> ==11714==  Address 0x5204068 is 0 bytes after a block of size 40 alloc'd
> ==11714==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
> ==11714==    by 0x400537: f (in /home/ejior/huangyue/linuxcode/exe)
> ==11714==    by 0x400555: main (in /home/ejior/huangyue/linuxcode/exe)
> ==11714== 
> ==11714== 
> ==11714== HEAP SUMMARY:
> ==11714==     in use at exit: 40 bytes in 1 blocks
> ==11714==   total heap usage: 1 allocs, 0 frees, 40 bytes allocated
> ==11714== 
> ==11714== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1
> ==11714==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
> ==11714==    by 0x400537: f (in /home/ejior/huangyue/linuxcode/exe)
> ==11714==    by 0x400555: main (in /home/ejior/huangyue/linuxcode/exe)
> ==11714== 
> ==11714== LEAK SUMMARY:
> ==11714==    definitely lost: 40 bytes in 1 blocks
> ==11714==    indirectly lost: 0 bytes in 0 blocks
> ==11714==      possibly lost: 0 bytes in 0 blocks
> ==11714==    still reachable: 0 bytes in 0 blocks
> ==11714==         suppressed: 0 bytes in 0 blocks
> ==11714== 
> ==11714== For counts of detected and suppressed errors, rerun with: -v
> ==11714== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
> ```
>
> 

C++加速命令，属于编译优化，慎用

```c++
#pragma GCC optimize("Ofast")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("avx,avx2,sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native")
#pragma GCC optimize("fast-math")
#pragma GCC optimize("inline")

static const int _ = []() {
	ios::sync_with_stdio(false);
	cin.sync_with_stdio(false);
	cout.sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	return 0;
}();
```

