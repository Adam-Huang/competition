# REFERENCE

- [linux C++后台开发面试题](<https://zhuanlan.zhihu.com/p/103027724>)
- [知乎：程序员面试，面试官更注重代码量、项目经验还是操作系统、数据结构这种基础课程？两者比例是五五开还是多少？](https://www.zhihu.com/question/264198516)
- [复习参考指北](<https://blog.csdn.net/qq_40840459/category_7280605.html>)
- 

# 操作系统

## 进程和线程

1. 分别的概念 区别 适用范围 它们分别的通讯方式 不同通讯方式的区别优缺点
> [知乎 线程和进程的区别是什么？](<https://www.zhihu.com/question/25532384>)
> 做个简单的比喻：进程=火车，线程=车厢
>
> - 线程在进程下行进（单纯的车厢无法运行）
> - 一个进程可以包含多个线程（一辆火车可以有多个车厢）
> - 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
> - 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
> - 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
> - 进程间不会相互影响，**一个线程挂掉将导致整个进程挂掉**（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
> - 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
> - 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
> - 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

> 线程作为进程的一部分，扮演的角色就是怎么利用中央处理器去运行代码。这其中牵扯到的最重要资源的是中央处理器和其中的寄存器，和线程的栈（stack）。这里想强调的是，线程关注的是中央处理器的运行，而不是内存等资源的管理。

> [操作系统—进程概念](<https://blog.csdn.net/qq_40840459/article/details/80058705>)
>
> **进程与程序**
>
> - 程序：代码段+数据段
> - 进程：代码段+数据段+堆栈+[PCB](#pcb)
>
> 进程是操作系统分配资源的基本单位，也是最小单位。每个进程有自己的独立地址空间和执行状态。 操作系统内核一定要有一个PCB来管理进程。（OS角度）
>
> **进程的状态**
>
> - 运行态：该进程正在运行，即进程正在占用CPU。
> - 就绪态：进程已经具备执行的一切条件，正在等待分配CPU的处理时间片。
> - 等待态：进程正在等待某个事件或某个资源。等待态又分为可中断等待和不可中断等待两种。可中断的等待进程可被信号中断，而不可中断的等待进程不能被信号中断。
> - 停止状态：当进程收到一个SIGSTOP信号后，便由运行态进入停止状态，当收到SIGCONT信号时又会恢复运行态，该状态主要用于调试。
> - 僵死状态（终止状态）：进程已终止，但其task_struct 结构仍在内存中。顾名思义，处于这种状态的进程实际是死进程。
>
> ![](https://img-blog.csdn.net/20180423173237921?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODQwNDU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



### [进程间通信（IPC）介绍](https://www.cnblogs.com/CheeseZH/p/5264465.html)

这个文章总结的很全面还有例子。

#### 管道

> 当一个管道建立时，它会创建两个文件描述符：`fd[0]`为读而打开，`fd[1]`为写而打开

这个`main`里的参数有点像，又有点想进程的标准输入输出的参数。有例子：

> ```c++
> #include<stdio.h>
> #include<unistd.h>
> 
> int main()
> {
> int fd[2];  // 两个文件描述符
> pid_t pid;
> char buff[20];
> 	printf("[line:%d] Parent pid:%d\n",__LINE__,getpid());
> 
> if(pipe(fd) < 0)  // 创建管道
>   printf("Create Pipe Error!\n");
> 
> if((pid = fork()) < 0)  // 创建子进程
>   printf("Fork Error!\n");
> else if(pid > 0)  // 父进程
> {
> 	printf("Parent pid:%d\n",pid);
>   close(fd[0]); // 关闭读端
>   write(fd[1], "hello world\n", 12);//12就是字符数吧
> }
> else
> {
> 	printf("Children pid:%d\n",pid);
>   close(fd[1]); // 关闭写端
>   read(fd[0], buff, 20);
>   printf("%s", buff);
> }
> 
> return 0;
> }
> ```
> OutPut:
> ```shell
> [line:9] Parent pid:14167 这是真正的Parent Thread
> Parent pid:14168 这是fork出来那个执行的
> Children pid:0  这是fork()的返回值，可参考frok用法
> hello world
> ```
> 还真能实现进程通信，但确实如前所述只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）
>

> [linux编程之pipe()函数](https://www.cnblogs.com/kunhu/p/3608109.html)
> ![pipe](https://images2015.cnblogs.com/blog/323808/201603/323808-20160311094030069-935122142.png)
>
> ```c++
> #include<unistd.h>
> int pipe(int filedes[2]); //返回值：成功，返回0，否则返回-1。参数数组包含pipe使用的两个文件的描述符。fd[0]:读管道，fd[1]:写管道。必须在fork()中调用pipe()，否则子进程不会继承文件描述符。两个进程不共享祖先进程，就不能使用pipe。
> ```
>
> 管道最大的劣势就是没有名字，只能用于有一个共同祖先进程的各个进程之间。FIFO代表先进先出，但它是一个单向数据流，也就是半双工，和管道不同的是：每个FIFO都有一个路径与之关联，从而允许无亲缘关系的进程访问。  

#### FIFO 命名管道

> 原型：
>
> ```c++
> #include <sys/stat.h>
> int mkfifo(const char *pathname, mode_t mode);
> // 返回值：成功返回0，出错返回-1。
> // 其中的 mode 参数与open函数中的 mode 相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它。
> ```
>
> FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时**清除数据**，并且“先进先出”。下面的例子演示了使用 FIFO 进行 IPC 的过程：
>
> ```c
> /*write_fifo.c*/
> #include<stdio.h>
> #include<stdlib.h>   // exit
> #include<fcntl.h>    // O_WRONLY
> #include<sys/stat.h>
> #include<time.h>     // time
> 
> int main()
> {
>     int fd;
>     int n, i;
>     char buf[1024];
>     time_t tp;
> 
>     printf("I am %d process.\n", getpid()); // 说明进程ID
> 
>     if((fd = open("../fifo1", O_WRONLY)) < 0) // 以写打开一个FIFO
>     {
>         perror("Open FIFO Failed");
>         exit(1);
>     }
> 
>     for(i=0; i<10; ++i)
>     {
>         time(&tp);  // 取系统当前时间
>         n = sprintf(buf,"Process %d's time is %s",getpid(),ctime(&tp));
>         printf("n: %d, Send message: %s", n, buf); // 打印
>         if(write(fd, buf, n+1) < 0)  // 写入到FIFO中
>         {
>             perror("Write FIFO Failed");
>             close(fd);
>             exit(1);
>         }
>         sleep(1);  // 休眠1秒
>     }
> 
>     close(fd);  // 关闭FIFO文件
>     return 0;
> }
> ```
>
> ```c
> /*read_fifo.c*/
> #include<stdio.h>
> #include<stdlib.h>
> #include<errno.h>
> #include<fcntl.h>
> #include<sys/stat.h>
> 
> int main()
> {
>     int fd;
>     int len;
>     char buf[1024];
> 	
> 	printf("I am %d process.\n", getpid()); // 说明进程ID
> 
>     if(mkfifo("../fifo1", 0666) < 0 && errno!=EEXIST) // 创建FIFO管道
>         perror("Create FIFO Failed\n");
> 
>     if((fd = open("../fifo1", O_RDONLY)) < 0)  // 以读打开FIFO
>     {
>         perror("Open FIFO Failed");
>         exit(1);
>     }
> 
>     while((len = read(fd, buf, 1024)) > 0) // 读取FIFO管道
>         printf("Read message: %s", buf);
> 
>     close(fd);  // 关闭FIFO文件
>     return 0;
> }
> ```
>
> Wonderful，My first multiprocessor program

`mkfifo`

> [mkfifo函数使用](<https://blog.csdn.net/superywf/article/details/73438465>)
>
> `mkfifo()`会依参数`pathname`建立特殊的`FIFO`文件，**该文件必须不存在，创建后文件存在**，
>
> ```shell
> prw-r--r--  1 root  root       0 6月   9 17:09 fifo1|
> ```
>
> 而参数`mode`为该文件的权限（mode%~umask），因此 umask值也会影响到`FIFO`文件的权限。

 `error 1: Create FIFO Failed: Operation not permitted`

   >[在共享文件夹里面创建管道mkfifo失败ubuntu](https://www.cnblogs.com/kirk1995/p/6654578.html) 
   >
   >原来是文件系统的问题，window的文件系统不支持管道文件，只要把创建的管道文件路径设为linux的本地文件夹就行了。刚开始我以为是hgfs文件夹权限的问题，于是在网上搜啊，还是没找到更改ubuntu下hgfs文件夹权限的方法，查到的都是说共享文件夹特殊，还是不要动的话。
   >
   >其实是和权限没关系的，就是文件系统问题，所以就算改了也还是不行的。

`errno`

   >[Linux errno详解](https://www.cnblogs.com/Jimmy1988/p/7485133.html) 
   >Linux中系统调用的错误都存储于 `errno`中，`errno`由操作系统维护，存储就近发生的错误，即下一次的错误码会覆盖掉上一次的错误。
   >
   >查看系统中所有的`errno`所代表的含义，可以采用如下的代码：
   >
   >```c++
   >/* Function: obtain the errno string
   >*   char *strerror(int errno)
   >*/
   >
   >#include <stdio.h>
   >#include <string.h>     //for strerror()
   >//#include <errno.h>
   >int main()
   >{
   >    int tmp = 0;
   >    for(tmp = 0; tmp <=256; tmp++)
   >    {
   >        printf("errno: %2d\t%s\n",tmp,strerror(tmp));
   >    }
   >    return 0;
   >}
   >// Linux中，在头文件 /usr/include/asm-generic/errno-base.h 对基础常用errno进行了宏定义：
   >// #define EEXIST      17  /* File exists */
   >```

`perror`

> [C 库函数 - perror()](<https://www.runoob.com/cprogramming/c-function-perror.html>)
>
> C 库函数 **void perror(const char \*str)** 把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 **str**，后跟一个冒号，然后是一个空格。
>
> ```c++
> void perror(const char *str)
> ```
>
> 

`fork`的用法：

> [Linux中fork（）函数详解](https://www.cnblogs.com/bastard/archive/2012/08/31/2664896.html)
>
> **fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：**
> 1）在父进程中，fork返回新创建子进程的进程ID；
> 2）在子进程中，fork返回0；
> 3）如果出现错误，fork返回一个负值；
>
> 引用一位网友的话来解释`fpid`的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的`fpid`(p 意味point)指向子进程的进程id,因为子进程没有子进程，所以其`fpid`为0.
>
> 创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。
> 每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过`getpid()`函数获得，还有一个记录父进程pid的变量，可以通过`getppid()`函数获得变量的值。
>
> [*9 June 2020*]这个写的不错，还有`fork`的进阶和高阶，我还没看。
>
> `nowcode`:最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。

`vfork`

> - `vfork`创建的子进程与父进程共享地址空间。
> - `fork`父子进程交替运行，`vfork`子进程运行，父进程阻塞，直到子进程结束
> - 每个系统上的`vfork`都有问题，建议不要使用

#### 消息队列

> ```c
> #include <sys/msg.h>
> // 创建或打开消息队列：成功返回队列ID，失败返回-1
> int msgget(key_t key, int flag);
> // 添加消息：成功返回0，失败返回-1
> int msgsnd(int msqid, const void *ptr, size_t size, int flag);
> // 读取消息：成功返回消息数据的长度，失败返回-1
> int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
> // 控制消息队列：成功返回0，失败返回-1
> int msgctl(int msqid, int cmd, struct msqid_ds *buf);
> ```
>
> ```shell
> sudo gcc msg_client.c -o msg_c; sudo gcc msg_server.c  -o msg_s
> ```
>
> ```c
> /*msg_server.c*/
> #include <stdio.h>
> #include <stdlib.h>
> #include <sys/msg.h>
> 
> // 用于创建一个唯一的key
> #define MSG_FILE "/etc/passwd"
> 
> // 消息结构
> struct msg_form {
>  long mtype;
>  char mtext[256];
> };
> 
> int main()
> {
>  int msqid;
>  key_t key;
>  struct msg_form msg;
> 
>  // 获取key值
>  if((key = ftok(MSG_FILE,'z')) < 0)
>  {
>      perror("ftok error");
>      exit(1);
>  }
> 
>  // 打印key值
>  printf("Message Queue - Server key is: %d.\n", key);
> 
>  // 创建消息队列
>  if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
>  {
>      perror("msgget error");
>      exit(1);
>  }
> 
>  // 打印消息队列ID及进程ID
>  printf("My msqid is: %d.\n", msqid);
>  printf("My pid is: %d.\n", getpid());
> 
>  // 循环读取消息
>  for(;;)
>  {
>      msgrcv(msqid, &msg, 256, 888, 0);// 返回类型为888的第一个消息
>      printf("Server: receive msg.mtext is: %s.\n", msg.mtext);
>      printf("Server: receive msg.mtype is: %d.\n", msg.mtype);
> 
>      msg.mtype = 999; // 客户端接收的消息类型
>      sprintf(msg.mtext, "hello, I'm server %d", getpid());
>      msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
>  }
>  return 0;
> }
> ```
> 在两个终端运行
> ```c
> /*msg_client.c*/
> #include <stdio.h>
> #include <stdlib.h>
> #include <sys/msg.h>
> 
> // 用于创建一个唯一的key
> #define MSG_FILE "/etc/passwd"
> 
> // 消息结构
> struct msg_form {
>  long mtype;
>  char mtext[256];
> };
> 
> int main()
> {
>  int msqid;
>  key_t key;
>  struct msg_form msg;
> 
>  // 获取key值
>  if ((key = ftok(MSG_FILE, 'z')) < 0)
>  {
>      perror("ftok error");
>      exit(1);
>  }
> 
>  // 打印key值
>  printf("Message Queue - Client key is: %d.\n", key);
> 
>  // 打开消息队列
>  if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
>  {
>      perror("msgget error");
>      exit(1);
>  }
> 
>  // 打印消息队列ID及进程ID
>  printf("My msqid is: %d.\n", msqid);
>  printf("My pid is: %d.\n", getpid());
> 
>  // 添加消息，类型为888
>  msg.mtype = 888;
>  sprintf(msg.mtext, "hello, I'm client %d", getpid());
>  msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
> 
>  // 读取类型为999的消息
>  msgrcv(msqid, &msg, 256, 999, 0);
>  printf("Client: receive msg.mtext is: %s.\n", msg.mtext);
>  printf("Client: receive msg.mtype is: %d.\n", msg.mtype);
>  return 0;
> }
> ```
>
> ```
> Message Queue - Client key is: 2047025538.
> My msqid is: 0.
> My pid is: 27106.
> Client: receive msg.mtext is: hello, I'm server 27053.
> Client: receive msg.mtype is: 999.
> ```
>
> ```
> Message Queue - Server key is: 2047025538.
> My msqid is: 0.
> My pid is: 27625.
> Server: receive msg.mtext is: hello, I'm client 27632.
> Server: receive msg.mtype is: 888.
> ```
>
> 

#### 信号量

> **信号量（semaphore）**与已经介绍过的 `IPC` 结构不同，它是一个**计数器**。信号量用于实现进程间的互斥与同步，**而不是用于存储进程间通信数据**。
>
> 1. 信号量用于进程间同步，若要在进程间传递数据需要结合**共享内存**。
> 2. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
> 3. ...
>
> ```c
> #include <sys/sem.h>
> // 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1
> int semget(key_t key, int num_sems, int sem_flags);
> // 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1
> int semop(int semid, struct sembuf semoparray[], size_t numops);
> // 控制信号量的相关信息
> int semctl(int semid, int sem_num, int cmd, ...);
> // 在semop函数中，sembuf结构
> struct sembuf
> {
>     short sem_num; // 信号量组中对应的序号，0～sem_nums-1
>     short sem_op;  // 信号量值在一次操作中的改变量
>     short sem_flg; // IPC_NOWAIT, SEM_UNDO
> }
> ```
>
> 在`semctl`函数中的命令有多种，这里就说两个常用的：
>
> - `SETVAL`：用于初始化信号量为一个已知的值。所需要的值作为联合semun的val成员来传递。在信号量第一次使用之前需要设置信号量。
> - `IPC_RMID`：删除一个信号量集合。**如果不删除信号量，它将继续在系统中存在**，即使程序已经退出，它可能在你下次运行此程序时引发问题，**而且信号量是一种有限的资源**。
>
> ```c
> #include<stdio.h>
> #include<stdlib.h>
> #include<sys/sem.h>
> 
> // 联合体，用于semctl初始化
> union semun
> {
>     int              val; /*for SETVAL*/
>     struct semid_ds *buf;
>     unsigned short  *array;
> };
> 
> // 初始化信号量
> int init_sem(int sem_id, int value)
> {
>     union semun tmp;
>     tmp.val = value;
>     if(semctl(sem_id, 0, SETVAL, tmp) == -1)
>     {
>         perror("Init Semaphore Error");
>         return -1;
>     }
>     return 0;
> }
> 
> // P操作:
> //    若信号量值为1，获取资源并将信号量值-1
> //    若信号量值为0，进程挂起等待
> int sem_p(int sem_id)
> {
>     struct sembuf sbuf;
>     sbuf.sem_num = 0; /*序号*/
>     sbuf.sem_op = -1; /*P操作*/
>     sbuf.sem_flg = SEM_UNDO;/*这个UNDO应该是值啥也不做等待信号量释放的意思吧*/
> 
>     if(semop(sem_id, &sbuf, 1) == -1)
>     {
>         perror("P operation Error");
>         return -1;
>     }
>     return 0;
> }
> 
> // V操作：
> //    释放资源并将信号量值+1
> //    如果有进程正在挂起等待，则唤醒它们
> int sem_v(int sem_id)
> {
>     struct sembuf sbuf;
>     sbuf.sem_num = 0; /*序号*/
>     sbuf.sem_op = 1;  /*V操作*/
>     sbuf.sem_flg = SEM_UNDO;
> 
>     if(semop(sem_id, &sbuf, 1) == -1)
>     {
>         perror("V operation Error");
>         return -1;
>     }
>     return 0;
> }
> 
> // 删除信号量集
> int del_sem(int sem_id)
> {
>     union semun tmp;
>     if(semctl(sem_id, 0, IPC_RMID, tmp) == -1)
>     {
>         perror("Delete Semaphore Error");
>         return -1;
>     }
>     return 0;
> }
> 
> 
> int main()
> {
>     int sem_id;  // 信号量集ID
>     key_t key;
>     pid_t pid;
> 
>     // 获取key值
>     if((key = ftok(".", 'z')) < 0)
>     {
>         perror("ftok error");
>         exit(1);
>     }
> 
>     // 创建信号量集，其中只有一个信号量
>     if((sem_id = semget(key, 1, IPC_CREAT|0666)) == -1)
>     {
>         perror("semget error");
>         exit(1);
>     }
> 	
> 	printf("Create Semaphore number:%d\n",sem_id);
>     // 初始化：初值设为0资源被占用，因此是子进程先执行，因为原本是0，子进程释放后才是1，sem_p操作才有效
>     init_sem(sem_id, 0);
> 
>     if((pid = fork()) == -1)//PS.从这个例子也很容易看出来，fork之后，子进程是接着父进程的点继续执行的
>         perror("Fork Error");
>     else if(pid == 0) /*子进程*/
>     {
>         sleep(2);
>         printf("Process child: pid=%d\n", getpid());
>         sem_v(sem_id);  /*释放资源*/
>     }
>     else  /*父进程*/
>     {
>         sem_p(sem_id);   /*等待资源*/
>         printf("Process father: pid=%d\n", getpid());
>         sem_v(sem_id);   /*释放资源*/
>         del_sem(sem_id); /*删除信号量集*/
>     }
>     return 0;
> }
> ```
>
> Output:
>
> ```shell
> Create Semaphore number:458766
> Process child: pid=3764
> Process father: pid=3763 # 父进程等待信号量，因此在子进程之后运行
> ```
>
> 

[*10 June 2020*] 

对于上述程序，还是有些细节没有深究，包括*信号量是一个有限资源，有多少？*等。

`PV操作`

> [操作系统——PV操作](<https://blog.csdn.net/ws_Ando/article/details/83501519>)
>
> PV操作概念：操作系统中的一种同步机制，实现对于并发进程中临界区的管理。
>
> 并发进程分为两种：
>
> ①无交互的并发进程：每个进程是相互独立的，谁也不影响谁，基本不会用到PV操作。
>
> ②有交互的并发进程：多个进程共享资源，一个进程的运行，有可能会被外界的原因而中断，且断点不固定。进程执行的相对速度不能由进程自己来控制，于是就会导致并发进程在共享资源的时出现与时间有关的错误。
>
> 临界区：并发进程中与共享变量有关的程序段都称为临界区。
>
> P操作：申请资源操作。
>
> V操作：释放资源操作。
> 

`原子操作`
> "原子操作(atomic operation)是不需要synchronized"，这是多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切 换到另一个线程）-- from baidubaike
>
> [原子操作](https://blog.csdn.net/just_kong/article/details/99289539) 有例子
> 上面的第一个不加锁程序肯定是最不推荐使用的，因为它的执行结果都不正确。第二个程序是使用的常规锁来解决问题，结果正确，但是耗时较久。第三个程序使用的是C++11引入的原子数据类型，使用它程序结果正确，在运行速度上也比加锁的版本快很多。所以，在我们平常写程序的过程中，推荐使用C++11引入的原子变量。
>
> Q：什么时候使用原子操作？
>
> 在多线程并发的条件下，所有不是原子性的操作需要保证原子性时，都需要进行原子操作处理
>
> ```c
> long count = 0;
> void func()
> {
>   count++;
> }
> ```
>
> 如果有n个线程同时执行这段代码，所有线程执行完后，count的值不一定等于n。因为count++不是一个原子操作，编译成汇编代码，如下所示：
>
> ```assembly
> MOV  eax, [count] # 先将 count所在内存的值加载到寄存器；
> INC  eax # 将寄存器的值自增1 -> 
>          # 此时cpu调度将此线程中断，并执行完其它线程后，再将此线程调度执行，会出错
> MOV [count], eax # 将寄存器中的值写回内存
> ```
>
> 

`ftok`

> [linux ftok（）函数](https://www.cnblogs.com/joeblackzqq/archive/2011/05/31/2065161.html)
>
> 系统建立IPC通讯（如消息队列、共享内存时）必须指定一个ID值。通常情况下，该id值通过`ftok`函数得到。
> `ftok`原型如下：
>
> ```c
> key_t ftok( char * fname, int id )
> //fname就时你指定的文件名(该文件必须是存在而且可以访问的)，id是子序号，虽然为int，但是只有8个比特被使用(0-255)。
> //当成功执行的时候，一个key_t值将会被返回，否则 -1 被返回。
> ```
>

#### 系统V共享内存

> 1. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
> 2. 因为多个进程可以同时操作，所以需要进行同步。
> 3. 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。
>
> ```c
> #include <sys/shm.h>
> /*当用shmget函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0 。
> 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1*/
> int shmget(key_t key, size_t size, int flag);
> 
> /*当一段共享内存被创建以后，它并不能被任何进程访问。必须使用shmat函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问。
> 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1*/
> void *shmat(int shm_id, const void *addr, int flag);
> 
> /*shmdt函数是用来断开shmat建立的连接的。注意，这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已。
> 断开与共享内存的连接：成功返回0，失败返回-1*/
> int shmdt(void *addr);
> 
> /*shmctl函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是IPC_RMID（从系统中删除该共享内存）。
> 控制共享内存的相关信息：成功返回0，失败返回-1*/
> int shmctl(int shm_id, int cmd, struct shmid_ds *buf);
> ```
>
> ```shell
> sudo gcc server.c -o server;sudo gcc client.c  -o client
> ```
> Output:
> ```shell
> Client Get the Key:2050097857
> ***************************************
> *                 IPC                 *
> *    Input r to send data to server.  *
> *    Input q to quit.                 *
> ***************************************
> Please input command: r
> Data to send: Hello Share memory!
> Please input command: Do not appect space?
> Wrong input!
> Please input command: r
> Data to send: 123456789 4
> Please input command: q
> 
> Server Get the Key:2050097857
> Hello
> 123456789
> ```

补充
> [来自：Linux环境进程间通信（五）共享内存（下）](https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html)
>
> 进程间需要共享的数据被放在一个叫做`IPC`共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。系统V共享内存通过`shmget`获得或创建一个`IPC`共享内存区域，并返回相应的标识符。内核在保证`shmget`获得或创建一个共享内存区，初始化该共享内存区相应的`shmid_kernel`结构注同时，还将在特殊文件系统`shm`中，创建并打开一个同名文件，并在内存中建立起该文件的相应`dentry`及`inode`结构，新打开的文件不属于任何一个进程（任何进程都可以访问该共享内存区）。所有这一切都是系统调用`shmget`完成的。
>
> `shmid_kernel`是共享内存区域中非常重要的一个数据结构，它是存储管理和文件系统结合起来的桥梁，定义如下：
>
> ```c
> struct shmid_kernel /* private to the kernel */
> {   
>     struct kern_ipc_perm    shm_perm;
>     struct file *       shm_file;
>     int         id;
>     unsigned long       shm_nattch;
>     unsigned long       shm_segsz;
>     time_t          shm_atim;
>     time_t          shm_dtim;
>     time_t          shm_ctim;
>     pid_t           shm_cprid;
>     pid_t           shm_lprid;
> };
> ```
>
> 在创建了一个共享内存区域后，还要将它映射到进程地址空间，系统调用`shmat()`完成此项功能。由于在调用`shmget()`时，已经创建了文件系统`shm`中的一个同名文件与共享内存区域相对应，因此，调用`shmat()`的过程相当于映射文件系统`shm`中的同名文件过程，原理与`mmap()`大同小异。
>
> **系统V共享内存限制**
>
> 在/proc/sys/kernel/目录下，记录着系统V共享内存的一下限制，如一个共享内存区的最大字节数shmmax，系统范围内最大共享内存区标识符数shmmni等，可以手工对其调整，但不推荐这样做。
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ ll /proc/sys/kernel/ | grep shm
> -rw-r--r-- 1 root root 0 5月   9 14:53 shmall
> -rw-r--r-- 1 root root 0 5月   9 14:53 shmmax
> -rw-r--r-- 1 root root 0 6月  10 17:16 shmmni
> -rw-r--r-- 1 root root 0 6月  10 17:16 shm_next_id
> -rw-r--r-- 1 root root 0 6月  10 17:16 shm_rmid_forced
> ```
>
> 

`IPC_CREATE|(0x666)`

> [Linux进程间通信——使用共享内存](<https://blog.csdn.net/ljianhui/article/details/10253345>)
>
> 共享内存的权限标志与文件的读写权限一样，举例来说，`0644`,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。
>
> 优点：我们可以看到使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。
>
> 缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段来进行进程间的同步工作。

#### 共享内存

上述共享内存是系统V共享内存[来自：Linux环境进程间通信（五）共享内存（下）](https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html)，其实还有另一种方式，这里补充一下。

> [Linux环境进程间通信（五）共享内存（上）](<https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html>)
>
> 这是一个不错的文章，还没看。

Q: 共享内存的使用实现原理（必考必问，然后共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？）



### 多线程

> [C++ 多线程](<https://www.runoob.com/cplusplus/cpp-multithreading.html>)
>
> **可移植操作系统接口**（英语：Portable Operating System Interface，缩写为**`POSIX`**）
>
> `pthread_create`是类Unix操作系统（Unix、Linux、Mac OS X等）的创建线程的函数。它的功能是创建线程（实际上就是确定调用该线程函数的入口点），在线程创建以后，就开始运行相关的线程函数。
>
> ```c++
> #include <pthread.h>
> int pthread_create(pthread_t *tidp, //指向线程标识符指针。
>              const pthread_attr_t *attr,//指定线程属性对象，也可以使用默认值 NULL
>              void *(*start_rtn)(void*),//线程运行函数起始地址，一旦线程被创建就会执行
>              void *arg);//运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。
> 
> void pthread_exit( void * value_ptr );
> //一个线程可以隐式的退出，也可以显式的调用pthread_exit函数来退出。
> ```
>
> ```c++
> #include <iostream>
> #include <cstdlib>
> #include <pthread.h>
> #include <unistd.h>
> 
> using namespace std;
> 
> #define NUM_THREADS     5
> 
> void *PrintHello(void *threadid)
> {  
>     // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取
>     sleep(3); // 添加sleep 假装同步
>     int tid = *((int*)threadid);
>     cout << "Hello Runoob! thread ID, " << tid << endl;
>     pthread_exit(NULL); //每个函数都有个这个
> }
> 
> int main ()
> {
>     pthread_t threads[NUM_THREADS];
>     int indexes[NUM_THREADS];// 用数组来保存i的值
>     int rc;
>     int i;
>     for( i=0; i < NUM_THREADS; i++ ){      
>            cout << "main() : Create thread, " << i;
>            indexes[i] = i; //先保存i的值 传入的时候必须强制转换为void* 类型，即无类型指针        
>            rc = pthread_create(&threads[i], NULL, PrintHello, (void *)&(indexes[i]));
>               cout << " indexes: " << indexes[i] << " threads[i]: " << threads[i] << endl;
>            if (rc){
>               cout << "Error:Create Thread Failed," << rc << endl;
>               exit(-1);
>            }
> 	}
> pthread_exit(NULL);
> }
> ```
>
> output:
>
> ```shell
> main() : Create thread, 0 indexes: 0threads[i]: 140680432002816 # 0x‭07FF2B72D2700‬
> main() : Create thread, 1 indexes: 1threads[i]: 140680423610112 # 0x0‭7FF2B6AD1700‬
> main() : Create thread, 2 indexes: 2threads[i]: 140680415217408 # 0x‭07FF2B62D0700‬
> main() : Create thread, 3 indexes: 3threads[i]: 140680406824704 # 0x0‭7FF2B5ACF700‬
> main() : Create thread, 4 indexes: 4threads[i]: 140680398432000 # 0x0‭7FF2B52CE700‬
> Hello Runoob! thread ID, 0
> Hello Runoob! thread ID, 3
> Hello Runoob! thread ID, 1
> Hello Runoob! thread ID, 2
> Hello Runoob! thread ID, 4
> # 每相邻线程pthread_t相差0x801000是地址空间嘛
> ```
>
> 在`sleep`时用`pstree -p`查看
>
> ```shell
> (base) ejior@ejior-XPS-8930:~/huangyue/linuxcode$ pstree -p 9223
> test.o(9223)─┬─{test.o}(9224)
>           ├─{test.o}(9226)
>           ├─{test.o}(9227)
>           ├─{test.o}(9228)
>           └─{test.o}(9229) # 如何设置线程名字呢？
> ```
>
> 之后有个想线程传递参数，我没run，因为原理很简单，就是将`pthread_create`的最后一个参数传入，就是一个指针，到线程内部在解析指针。

下面说说`pthread_attr_t`和线程的深度知识
>[pthread_attr_t 线程属性(一)](https://www.cnblogs.com/jacklikedogs/p/4030048.html)
>
>```c++
>#include <pthread.h>
>int pthread_attr_init(pthread_attr_t *attr);   // 初始化后使用，使用后还要进行去除初始化
>int pthread_attr_destroy(pthread_attr_t *attr);// 若成功返回0，若失败返回-1。
>
>typedef struct
>{
>       int                     detachstate;     // 线程的分离状态
>       int                     schedpolicy;     // 线程调度策略
>       struct sched_param      schedparam;      // 线程的调度参数
>       int                     inheritsched;    // 线程的继承性
>       int                     scope;           // 线程的作用域
>       size_t                  guardsize;       // 线程栈末尾的警戒缓冲区大小
>       int                     stackaddr_set;
>       void *                  stackaddr;       // 线程栈的位置
>       size_t                  stacksize;       // 线程栈的大小
>}pthread_attr_t;
>```
>
>**分离状态**
>
>线程的分离状态决定一个线程以什么样的方式来终止自己。在默认情况下线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束。只有当`pthread_join() `函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。
>
>通俗的说也就是：我们知道一般我们要等待(`pthread_join`)一个线程的结束，主要是想知道它的结束状态但是如果有一些线程的终止态我们压根就不想知道，那么就可以使用“分离”属性，那么我们就无须等待管理，只要线程自己结束了，自己释放资源就可以咯！这样更方便！
>
>```c++
>#include <pthread.h>
>int pthread_attr_getdetachstate(const pthread_attr_t * attr, int * detachstate);
>int pthread_attr_setdetachstate(pthread_attr_t * attr, int detachstate);
>```
>
>设置的时候可以有两种选择：
>
>- `detachstate`参数为：`PTHREAD_CREATE_DETACHED`     分离状态启动
>- `detachstate`参数为：`PTHREAD_CREATE_JOINABLE`    正常启动线程
>
>在任何一个时间点上，线程是可结合的（`joinable`），或者是分离的（`detached`）。一个可结合的线程能够被其他线程收回其资源和杀死；在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。[线程分离状态的理解](<https://blog.csdn.net/jobbofhe/article/details/52252736>)
>
>[以分离状态创建线程](<https://blog.csdn.net/pbymw8iwm/article/details/6721038>)
>
>```c++
>#include<pthread.h>
>void *child_thread(void *arg)
>{
>	printf(“child thread run!\n”);
>}
>
>int main(int argc,char *argv[ ])
>{
>      pthread_ttid;
>      pthread_attr_tattr;
>      pthread_attr_init(&attr);
>      pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_DETACHED);
>      pthread_create(&tid,&attr,fn,arg);
>      pthread_attr_destroy(&attr);
>      sleep(1);
>}
>```
>
>所以说这个“分离”与不分离，其实只对资源有用，在使用过程中对调度其实没多大影响？
>
>**线程的继承性**
>
>```c++
>#include <pthread.h>
>int pthread_attr_getinheritsched(const pthread_attr_t *attr,int *inheritsched);
>int pthread_attr_setinheritsched(pthread_attr_t *attr,int inheritsched); //若成功返回0，若失败返回-1。
>/*PTHREAD_INHERIT_SCHED： 新的线程继承创建线程的策略和参数！
>  PTHREAD_EXPLICIT_SCHED：新的线程继承策略和参数来自于schedpolicy和schedparam属性中显式设置的调度信息！*/
>```
>
>
>
>**线程的调度策略**
>
>```c++
>int pthread_attr_getschedpolicy(const pthread_attr_t*attr,int *policy);
>int pthread_attr_setschedpolicy(pthread_attr_t *attr,intpolicy);
>```
>
>调度策略可能的值是先进先出（`SCHED_FIFO`）、轮转法（`SCHED_RR`）,或其它（`SCHED_OTHER`）。
>
>- `SCHED_FIFO`策略允许一个线程运行直到有更高优先级的线程准备好，或者直到它自愿阻塞自己。在`SCHED_FIFO`调度策略下，当有一个线程准备好时，除非有平等或更高优先级的线程已经在运行，否则它会很快开始执行。
>- `SCHED_RR`(轮循)策略是基本相同的，不同之处在于：如果有一个`SCHED_RR`策略的线程执行了超过一个固定的时期*(*时间片间隔*)*没有阻塞，而另外的`SCHED_RR`或`SCHBD_FIPO`策略的相同优先级的线程准备好时，运行的线程将被抢占以便准备好的线程可以执行。
>- 当有`SCHED_FIFO`或`SCHED_RR`策赂的线程在一个条件变量上等持或等持加锁同一个互斥量时，它们将以优先级顺序被唤醒。即，如果一个低优先级的`SCHED_FIFO`线程和一个高优先织的`SCHED_FIFO`线程都在等待锁相同的互斥且，则当互斥量被解锁时，**高优先级线程将总是被首先解除阻塞**。
>
>**线程的调度参数**
>
>```c++
>int pthread_attr_getschedparam(const pthread_attr_t*attr,struct sched_param *param);
>int pthread_attr_setschedparam(pthread_attr_t *attr,conststruct sched_param *param);
>```
>
>`sched_param`详细可参见：[struct sched_param 结构体](<https://blog.csdn.net/weixin_38239856/article/details/82117600>)
>
>[linux线程调度策略](<https://www.cnblogs.com/charlieroro/p/12133100.html>) 这是一篇非常好的关于线程调度的资料，翻译自[shed](<https://man7.org/linux/man-pages/man7/sched.7.html>)
>
>**线程的作用域**
>
>```c++
>/*线程的作用域*/
>int tscope;
>ret = pthread_attr_getscope(&attr,&tscope);
>if(ret){
>    cout << "getscope Failed!" << endl;
>    exit(-1);
>}
>
>if(tscope == PTHREAD_SCOPE_PROCESS) cout << "PTHREAD_SCOPE_PROCESS" << endl;
>if(tscope == PTHREAD_SCOPE_SYSTEM)  cout << "PTHREAD_SCOPE_SYSTEM" << endl;
>```
>
>```shell
>PTHREAD_SCOPE_SYSTEM
>```
>
>**线程堆栈的大小**
>
>```c++
>/*线程堆栈的大小*/
>size_t stacksize;
>ret = pthread_attr_getstacksize(&attr,&stacksize);
>if(ret){
>    cout << "getstacksize Failed!" << endl;
>    exit(-1);
>}
>
>cout << "getstacksize:" << stacksize << endl;//8,388,608 = 0x800000 = 8M
>```
>
>这个是堆栈大小，是堆的还是栈的？
>
>**线程堆栈的地址**
>
>堆栈地址函数没用好。输出都是0。先这样吧后续有需求再补充。

#### 堆栈大小

从上面的例子也可以看出来，至少这个机器是`8M`的栈空间或者用命令`ulimit -s`查看（`ulimit -a`可以查看所有信息），至于堆嘛：

> [进程空间分配和堆栈大小](https://www.cnblogs.com/ladawn/p/8449399.html) 
>
> 堆的大小理论上大概等于进程虚拟空间大小-内核虚拟内存大小。windows下，进程的高位`2G`留给内核，低位`2G`留给用户，所以进程堆的大小小于`2G`。Linux下，进程的高位`1G`留给内核，低位`3G`留给用户，所以进程堆大小小于`3G`。

#### 线程阻塞

> [linux系统排查线程阻塞问题](<https://blog.csdn.net/qq_42609381/article/details/81412266>)
>
> ```shell
> [root@Joe ~]# pstack 11694 > one
> [root@Joe ~]# pstack 11694 > two
> [root@Joe ~]# diff one two
> ```
>
> ```shell
> [root@Joe ~]# strace -p 11694
> ```

`pstack`

> [pstack命令](<https://man.linuxde.net/pstack>) 有例子，这里我就不粘贴了，和之前看到的很像。
>
> 可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 `root` 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 `PID`。
>
> [pstack使用和原理](https://www.cnblogs.com/mumuxinfei/p/4366708.html) 有个小总结
>
> 对`pstack`的作用, 大致可以归纳如下:
> 　1). 查看线程数(比`pstree`, 包含了详细的堆栈信息)
>        2). 能简单验证是否按照预定的调用顺序/调用栈执行
> 　3). 采用高频率多次采样使用时, 能发现程序当前的阻塞在哪里, 以及性能消耗点在哪里?
> 　4). 能反映出疑似的死锁现象(多个线程同时在wait lock, 具体需要进一步验证)

`strace`

> strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。
>
> 链接：https://www.jianshu.com/p/d6686cb72f68

## 僵尸进程



## 死锁

死锁是怎么产生的

死锁检测

> [linux死锁检测的一种思路](https://www.cnblogs.com/mumuxinfei/p/4365697.html) 有代码：`D:\00-personal\05-code\dead_lock_sample`
>
> 这个用拓扑排序解决死锁，很新颖嘛。



1. CPU的执行方式
2. 代码中遇到进程阻塞，进程僵死，内存泄漏，程序崩溃等情况怎么排查。

## 协程


1. 有没有了解过协程？说下协程和线程的区别？

2. 堆是线程共有还是私有，堆是进程共有还是私有，栈呢

   

   
## 内存空间分布
   c++进程内存空间分布（注意各部分的内存地址谁高谁低，注意栈从高道低分配，堆从低到高分配）

   > [c++进程内存空间分布](<https://blog.csdn.net/xiaozuo2017/article/details/81452869>)
   >
   > 内存分布分为5个部分，从高地址到低地址依次为 栈区（stack），堆区（heap），未初始化数据段（uninitialized data），初始化数据段（initialize data），代码段（text）。
   >
   > ![](http://www.geeksforgeeks.org/wp-content/uploads/Memory-Layout.gif)
   >
   > ![hehe](https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153)
   >
   > 

   ## PCB

> 为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为[进程控制块](https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97/7205297)（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。
>
> [PCB（进程控制块）讲解](<https://blog.csdn.net/IT_10/article/details/89819138>)
>
> PCB：进程控制块，实际是一个结构体，放在`sched.h`文件中，Linux下可以通过`whereis sched.h`命令查看具体路径

3. ELF是什么？其大小与程序中全局变量的是否初始化有什么关系（注意.bss段）

4. 使用过哪些进程间通讯机制，并详细说明（重点）

5. 多线程和多进程的区别（重点 面试官最最关心的一个问题，必须从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）

6. 信号：列出常见的信号，信号怎么处理？

7. i++是否原子操作？并解释为什么？？？？？？？

8. 说出你所知道的各类linux系统的各类同步机制（重点），什么是死锁？如何避免死锁（每个技术面试官必问）

9. 列举说明linux系统的各类异步机制

10. exit() _exit()的区别？

11. 如何实现守护进程？

12. linux的内存管理机制是什么？

13. linux的任务调度机制是什么？

14. 标准库函数和系统调用的区别？

15. 补充一个坑爹坑爹坑爹坑爹的问题：系统如何将一个信号通知到进程？（这一题哥没有答出来）

16. [多线程有什么好处？](https://www.cnblogs.com/liuyangofficial/p/7072595.html)What are the benefits of multithreading?

    



# Linux系统

1. linux的各种命令 给你场景让你解决

2. Linux了解么，查看进程状态ps，查看cpu状态 top。查看占用端口的进程号netstat grep

3. Linux的cpu 100怎么排查，top jstack，日志，gui工具

4. Linux操作系统了解么

5. 怎么查看CPU负载，怎么查看一个客户下有多少进程

6. Linux内核是怎么实现定时器的

7. gdb怎么查看某个线程

8. core dump有没有遇到过，gdb怎么调试

9. linux如何设置core文件生成

10. linux如何设置开机自启动

11. linux用过哪些命令、工具

12. 用过哪些工具检测程序性能，如何定位性能瓶颈的地方

13. netstat tcpdump ipcs ipcrm （如果这四个命令没听说过或者不能熟练使用，基本上可以回家，通过的概率较小 ^_^ ，这四个命令的熟练掌握程度基本上能体现面试者实际开发和调试程序的经验)

    

14. cpu 内存 硬盘 等等与系统性能调试相关的命令必须熟练掌握，设置修改权限 tcp网络状态查看 各进程状态 抓包相关等相关命令 必须熟练掌握

15. awk sed需掌握

16. gdb调试相关的经验，会被问到

# Compile

## g++和gcc

> [g++和gcc的相同点和区别](<https://blog.csdn.net/hitwengqi/article/details/8013754>) 有参数详解
>
> `-lpthread` : `-llibrary` 制定编译的时候使用的库。例子用法
>
> ```shell
> gcc -lcurses hello.c # 使用ncurses库编译程序
> ```

